<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0046)http://progmaph.epfl.ch/projet/tutoriel_Qt.php -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr"><script>(function(){var DPA=function(p){for(var i=0;i<p.length;i++){this[i]=this[p[i].name]=p[i];}var a={name:"DjVu Plugin Viewer",filename:"djvu.js",description:"This is just a test package for incoming Chrome DjVu Plugin."};this[p.length]=this[a.name]=a;this.length=p.length+1;};DPA.prototype.item=function(n){return this[n];};DPA.prototype.namedItem=function(name){for(var i=0;i<this.length;i++){if(this[i].name===name){return this[i];}}};DPA.prototype.refresh=function(){location.reload(true);};var p=new DPA(navigator.plugins);Object.defineProperty(navigator,"plugins",{get:function(){return p}});})()</script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="Content-Style-Type" content="text/css">
    <meta http-equiv="Expires" content="Tue, 10 Jul 2002 12:00:00 GMT">
    <link rel="stylesheet" href="./Tutoriel OpenGL + Qt_files/tutograph.css" charset="utf-8" type="text/css">
    <link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="./Tutoriel OpenGL + Qt_files/geshi-test-2-visuel1.css" title="visuel 1">
    <link rel="alternate stylesheet" type="text/css" charset="utf-8" media="screen" href="./Tutoriel OpenGL + Qt_files/geshi-test-2-visuel2.css" title="visuel 2">
    <link rel="alternate stylesheet" type="text/css" charset="utf-8" media="screen" href="./Tutoriel OpenGL + Qt_files/geshi-test-2-nocomment.css" title="No Comment">
    <link rel="alternate stylesheet" type="text/css" charset="utf-8" media="print,screen" href="./Tutoriel OpenGL + Qt_files/geshi-test-2-print.css" title="impression NB">
    <title>
      Tutoriel OpenGL + Qt    </title>
  <link id="noteanywherecss" media="screen" type="text/css" rel="stylesheet" href="data:text/css,.note-anywhere%20.closebutton%7Bbackground-image%3A%20url%28chrome-extension%3A//bohahkiiknkelflnjjlipnaeapefmjbh/asset/deleteButton.png%29%3B%7D%0A"></head>
  <body class="text">
<!-- Begin header -->
    <table width="90%" align="center">
      <tbody><tr>
        <td valign="top" width="100%">
          <hr>
          <strong>Faculté Informatique &amp;
          Communications</strong><br>
          Cours d'informatique<br>
          <hr>
        </td>
        <td align="right" valign="top">
          <img width="110" src="./Tutoriel OpenGL + Qt_files/epfl_logo.gif" alt="EPFL"><br>
          <img width="110" src="./Tutoriel OpenGL + Qt_files/epfl_text.gif" alt="EPFL">
        </td>

      </tr>
    </tbody></table><!-- End header -->
    <h1>
      Tutoriel OpenGL + Qt   </h1>

    
    <!-- ToC -->
    <a name="intro" id="intro"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>

        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
        </li>
        <li>

          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Introduction
    </h2>
    <p>
      Dans tous les programmes que vous avez écrits jusqu'à
      maintenant, vous disposiez du terminal pour afficher et
      saisir du texte. Ceci est insuffisant pour permettre
      d'afficher des graphismes évolués et offrir une interaction
      «&nbsp;vivante&nbsp;» avec l'utilisateur. Ce document a pour but de vous
      donner les bases nécessaires pour programmer en utilisant les
      bibliothèques de fonctions graphiques Qt et OpenGL. Nous
      abordons également le thème de la simulation dans un
      environnement graphique en temps réel. 
    </p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Le matériel présenté ici ne faisant
      pas partie des objectifs du cours (mais étant simplement un
      outil pour le projet de cette année), nous aurons une
      approche pratique par l'exemple, très superficielle, plutôt
      qu'une approche théorique et complète.
    </p>
    <p>
      OpenGL propose une série de fonctions évoluées, compatibles
      avec toutes les plates-formes (Unix, Linux, MacOS, ...) et
      très performantes. Le dessin s'effectue grâce à des
      primitives géométriques (e.g. polygones) en 2D ou 3D. Ces
      primitives peuvent êtres colorées, texturées et animées.
    </p>
    <p>
      De son coté, la bibliothèque Qt s'occupe de
      l'interaction avec l'utilisateur. Elle permet en effet de
      gérer, entre autres&nbsp;:
    </p>

    <ul>
      <li>les entrées clavier et souris&nbsp;;
      </li>
      <li>le temps&nbsp;;
      </li>
      <li>la fenêtre graphique&nbsp;;
      </li>
    </ul>
    <p>
       ceci de façon indépendante de la plate-forme.
    </p>

    <p class="note"> <strong>NOTE&nbsp;:</strong> OpenGL et Qt      ne sont, bien entendu, pas les seules bibliothèques permettant
      d'effectuer ces tâches. Vous pourriez
      aussi par exemple utiliser
      <a href="http://progmaph.epfl.ch/projet/tutoriel_graphisme.php?lib=wxw">wxWidgets</a> ou
      <a href="http://progmaph.epfl.ch/projet/tutoriel_graphisme.php?lib=sdl">SDL</a>,
<!--
      ou <a href="tutoriel_glut.html" >glut</a>
-->
             ou tout autre bibliothèque de votre choix à la place de Qt. 
 Mais Qt est bien la bibliothèque que nous vous recommandons pour ce projet.
    </p>

    <p>Le présent tutoriel ne constitue qu'une brève présentation de ces deux
    bibliothèques (Qt et OpenGL). La meilleure méthode
    d'apprentissage est de lire chaque exemple en entier, puis
    compiler l'exemple et regarder ce qui se passe en interagissant
    avec le programme. Dans un troisième temps, il est intéressant de
    modifier les paramètres des fonctions présentées (couleurs,
    positions, touches appuyées,...) afin de voir ce qui
    change. Finalement vous pouvez essayer de refaire le même
    programme.</p>

    <p>Concernant le plan de ce document :</p>
    <ol>
      <li><p>Nous commencerons par <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">un exemple simple de dessin direct</a> d'OpenGL via Qt.</p><p>Cet exemple présentera les concepts de </p>
      <ul>
        <li>fenêtre OpenGL : bases pour dessiner en 3D ;</li>
        <li>shaders : version moderne d'écriture d'OpenGL permettant des optimisations par la carte graphique ;</li>
        <li><code>qmake</code> : utilitaire pour générer les <code class="file">Makefile</code>s et compiler.</li>
      </ul>
    </li>
      <li><p>Nous travaillerons ensuite sur <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl2">la conception, la structure du programme</a>, de sorte à séparer clairement les objets d'un coté et leur(s) dessin(s) de l'autre.</p><p>Cet exemple montrera aussi comment dessiner un cube.</p></li>
      <li><p>Puis nous verrons comment <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl3">dessiner plusieurs objets</a>, les placer les uns par rapport aux autres.</p></li>
      <li><p>Dans <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">le quatrième exemple</a>, nous ajouterons un « point de vue » que l'on peut déplacer.</p><p>Les exemples suivants (sauf le neuvième) proposent alors plusieurs extensions différentes à partir de ce quatrième exemple.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl5">Le cinquième exemple</a> étend le quatrième en ajoutant une gestion du mouvement et du temps.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Le sixième exemple</a> étend le quatrième en remplaçant le dessin des cubes par celui de sphère .</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Le septième exemple</a> étend le quatrième en ajoutant des déplacement à la souris.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Le huitième exemple</a> étend le quatrième en ajoutant des textures sur les faces des cubes.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl9">Le neuvième et dernier exemple</a> enfin repart de du tout premier exemple, simple, pour montrer comment faire du dessin en 2D.</p></li>
</ol>

<p>Ceux qui veulent aller vite de façon minimale peuvent essayer de ne regarder que <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl5">l'exemple 5</a>.<br>
Ceux qui veulent aller un peu moins vite peuvent suivre les exemples de 1 à 5.<br>
Et ceux qui sont intéressés peuvent continuer avec les exemples 6 à 9.</p>
    
    <!-- ToC -->
    <a name="d3d" id="d3d"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>

        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
          <ul class="subnavlist">
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Concepts de base</a>
            </li>
            <li>

              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">Premier dessin</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl2">Conception</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl3">Plusieurs objets</a>

            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">Point de vue et gestion clavier</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>

        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>

    </div>
    <h2>
      Dessin 3D
    </h2>
    <h3>
      Quelques concepts de base
    </h3>
    <h4>
      Boucle principale
    </h4>

    <p> La première chose qu'il faut bien comprendre quand on utilise
      une bibliothèque graphique telle que Qt, c'est qu'il ne
      s'agit pas d'un programme de dessin séquentiel («&nbsp;dessine ceci&nbsp;»,
      puis «&nbsp;dessine cela&nbsp;», etc.), mais de «&nbsp;<em>programmation
      événementielle</em>&nbsp;» (i.e. «&nbsp;à base d'<em>évènements</em>&nbsp;») où
      tout se passe dans une boucle infinie qui ne fait qu'attendre des
      évènements (clic de souris, touche au clavier,
      redimensionnement de la fenêtre ou tout simplement l'évènement «&nbsp;dessine&nbsp;») et
      appelle les fonctions correspondant à ces évènements.  </p> <p>
      Une première étape consiste donc à programmer toutes ces
      fonctions que l'on veut associer à des évènements.  </p> <p> Une
      seconde étape consiste à initialiser tout ce qu'il faut (e.g. la
      fenêtre de dessin, les boutons, barres, etc.) </p>

    <p>
      Puis enfin (et seulement en fin&nbsp;!) on lance la fameuse boucle
      infinie. Ce n'est qu'une fois cette boucle lancée que l'on
      pourra voir quelque chose. De manière générale, la boucle se
      déroule de la manière suivante&nbsp;:
    </p>
    <ol>
      <li>gestion des évènements&nbsp;;
      </li>
      <li>évolution du système (évènements « Timer », en fait ; donc cas particulier du 1.)&nbsp;;
      </li>
      <li>dessin de la nouvelle image.
      </li>
    </ol>

    <p>Ces étapes seront détaillées plus loin dans ce tutoriel.
    </p>

    <!--
    <p class="note">
      <strong>NOTE&nbsp;:</strong> Cette boucle étant une boucle
      infinie, il faudra bien sûr penser à associer à un évènement
      particulier le fait de quitter le programme. Nous reviendrons
      sur ce point plus tard, dans notre second exemple.
    </p>
    -->
    
    <p>Dans la panoplie d'outils disponibles dans la bibliothèque Qt, il existe
    une couche spécifique pour la gestion des représentations 2D et
    3D. Cette couche s'appelle OpenGL, et c'est sur elle que nous
    allons maintenant nous focaliser.
    </p>
    
    <p class="note">
      <strong>NOTE&nbsp;:</strong> OpenGL n'est pas à strictement
      parler un composant de la bibliothèque Qt, mais une couche plus basse,
      indépendante, à laquelle on peut «&nbsp;parler&nbsp;» et que l'on peut
      incorporer dans les objets de Qt.
    </p>

    <a name="matcur" id="matcur"></a>
    <h4>
      Matrice de dessin
    </h4>

    <p> Pour comprendre les commandes graphiques que vous allez
    utiliser, la seconde chose qu'il faut bien comprendre sont
    les «&nbsp;matrices de point de vue&nbsp;».  </p>

    <p>
      Ce sont des matrices «&nbsp;affines&nbsp;» (i.e. 4x4 pour un espace vectoriel 3D plus une translation)
      représentant la composition des transformations
      géométriques ayant été effectuées jusque là. Toutes transformations géométriques sont en fait représentées par des
      matrices 4x4 (et les objets par des vecteurs 4D, un par sommets, comme expliqué plus loin).
    </p>
    <p>
      ATTENTION&nbsp;! Cela suppose aussi que l'on utilise l'ordre de
      composition des fonctions&nbsp;: appliquer f, puis appliquer g,
      c'est en fait faire g(f(x)). Ceci implique que si vous multipliez à droite la matrice courrante par
      une matrice de translation puis par une matrice de rotation séquentiellement dans le
      code, et bien à l'écran, c'est comme s'il y avait d'abord eu
      une rotation, puis seulement ensuite une translation&nbsp;!
      Faites donc attention à l'ordre de vos commandes graphiques.
    </p>

    <p>Dans ce tutoriel, les matrices seront représentées à l'aide de la classe <code class="code">QMatrix4x4</code>. Nous passerons les matrices à OpenGL plus précisément à ce que l'on appelle des « <em>shaders</em> ».
    </p>

    <a name="shaders"></a>
    <h4>
      « Shaders »
    </h4>

<p>
Pour dessiner rapidement, OpenGL permet d'utiliser « l'accélération 3D
» des cartes graphiques modernes (« GPU » pour « <em>Graphics
Processing Unit</em> ») . Un dessin rendu avec OpenGL sera fait plus
rapidement si l'on utilise directement le GPU que si l'on utilise
uniquement le processeur (« CPU » pour « <em>Central Processing
Unit</em> »).
</p>

<p> Pour utiliser le GPU dans OpenGL, il faut écrire le programme
correspondant dans un langage de programmation spécifique, le « GLSL »
pour « <em>OpenGL Shading Language</em> ».  C'est un langage assez proche du C (ancêtre du C++),
mais particulièrement adapté à l'architecture des "GPU".
Un programme en GLSL s'appelle techniquement un « <em>shader</em> ».
</p>

<p>
Dans ce tutoriel, nous ne vous expliquerons bien sûr pas le langage GLSL (cela nous emmènerait beaucoup trop loin).
Nous vous fournissons plutôt des « shaders » déjà faits, très basiques (une douzaine de lignes de code en tout) mais qui permettent quand même de dessiner un tas de choses, suffisantes pour ce cours.
</p>

<p>Techniquement parlant, les « shaders » que nous vous fournissons
permettent de dessiner des primitives colorées (par exemple : un triangle
rouge ou un parallélogramme bleu)  auxquelles on peut appliquer des
transformations géométriques comme par exemple une translation, une
rotation ou une homothétie en utilisant une <code class="code">QMatrix4x4</code>.
Tout ceci sera détaillé plus bas.
</p>

    <a name="install" id="install"></a>
    <h4>
      Pour installer
    </h4>

    <p>Qt et OpenGL sont installées sur les ordinateurs du
    CO. Si vous voulez utiliser ces bibliothèques chez vous, il faudra
    les installer.  </p>
    
    <ul> <li> <p>Sous Linux&nbsp;: OpenGL est en général installé par
      défaut et la bibliothèque Qt      devrait se trouver dans les dépôts sous le nom
<code>libqt4-dev</code>, ou alors <code>qt-sdk</code> si vous voulez tout l'environnement de développement.      </p>
      </li>

	<li><p>autres OS&nbsp;: OpenGL est normalement fourni avec votre compilateur. Qt est téléchargeable ici&nbsp;: <a href="http://www.qt.io/download/" target="other">Téléchargement Qt</a>.
      </p>
      </li>
    </ul>   
	

    <a name="makefile" id="makefile"></a>
    <h4>
      Pour compiler
    </h4>

    <p>
      Pour compiler un programme avec les bibliothèques
      Qt et OpenGL, il est nécessaire de donner
      au compilateur des directives dans ce sens.
    </p>


    <p>
    Qt utilise un mécanisme (et un langage) qui lui est propre pour générer ses <code>Makefile</code>&nbsp;: <code>qmake</code>.
   </p> 

    <p>Pour générer le(s) <code>Makefile</code>, <code>qmake</code> utilise un fichier «&nbsp;<code>.pro</code>&nbsp;» que nous vous expliquerons plus loin. La procédure consiste donc à faire</p>
    <pre>qmake fichier.pro</pre>
    <p>ou simplement</p>
    <pre>qmake</pre>
    <p>en général une seule fois (à moins de modifier le  fichier «&nbsp;<code>.pro</code>&nbsp;» ), puis</p>
    <pre>make</pre>
    <p>comme d'habitude à chaque fois que vous voulez recompiler.</p>
    
    <!-- ToC -->
    <a name="exmpl1" id="exmpl1"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>

        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
          <ul class="subnavlist">
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Concepts de base</a>
            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">Premier dessin</a>

            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl2">Conception</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl3">Plusieurs objets</a>
            </li>
            <li>

              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">Point de vue et gestion clavier</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li>

          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>


    <h3>
      Premier exemple&nbsp;: dessiner un triangle coloré
    </h3>
    <p>
      Commençons par un premier exemple simple consistant à
      dessiner un triangle coloré, vu de face (on est en 3D)
    </p>
    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01.zip">télécharger ici le code de ce premier
      exemple</a>. Décompressez l'archive (par exemple avec <code>unzip</code>). allez dans le répertoire <code>ex_01</code>, tapez <code>qmake</code> puis <code>make</code>. Enfin, lancez l'exécutable en tapant <code>./ex_01</code>. Pour résumer :
    </p>
    <pre class="note">unzip ex_01.zip 
cd ex_01
qmake
make
./ex_01 
</pre>
    <p class="note">Et si nécessaire, pour repartir depuis zéro, effacer tous les fichiers intermédiaires, faire : <code>make distclean</code></p>

    <p>Pour commencer notre programme, la première chose à faire est de construire une fenêtre
    permettant de dessiner de l'OpenGl.
    </p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Qt    est en fait une bibliothèque très riche qui permet de définir
    toutes sortes d'objets graphiques (boutons, règles, ascenseurs,
    ...)
et peut tout à fait fonctionner sans OpenGL. On pourrait donc bien sûr ajouter plusieurs autres objets graphiques, mais ce n'est pas le propos du présent tutoriel.
    </p>
    
<p>Pour simplifier et éviter d'entrer dans les détails ici, nous vous avons écrit un programme <code>main()</code> (voir le <a href="http://progmaph.epfl.ch/projet/src/qt/common/Qt_GL/main_qt_gl.cc">fichier <code class="file">main_qt_gl.cc</code></a> fourni) et une classe (<code>GLWidget</code>) qui font cela pour vous. Il n'est pas nécessaire de comprendre le <code>main()</code>, qui ne changera pas pour tout ce tutoriel, ni tous les détails de la classe <code>GLWidget</code>, mais simplement quelques unes de ses parties, que nous expliquerons au fur et à mesure.
</p>

<p>Cette classe (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/glwidget.h">fichier <code class="file">glwidget.h</code></a>) :</p>    
<pre class="cpp"><span class="co2">#ifndef GLWIDGET_H</span>
<span class="co2">#define GLWIDGET_H</span>
&nbsp;
<span class="co2">#include &lt;QGLWidget&gt;        // Classe pour faire une fenêtre OpenGL</span>
<span class="co2">#include &lt;QGLShaderProgram&gt; // Classe qui wrap les fonctions OpenGL liées aux shaders</span>
&nbsp;
<span class="kw2">class</span> GLWidget <span class="sy4">:</span> <span class="kw2">public</span> QGLWidget
<span class="coMULTI">/* La fenêtre hérite de QGLWidget ;
 * les événements (clavier, souris, temps) sont des méthodes virtuelles à redéfinir.
 */</span>
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  GLWidget<span class="br0">(</span>QWidget<span class="sy2">*</span> parent <span class="sy1">=</span> nullptr<span class="br0">)</span>
    <span class="sy4">:</span> QGLWidget<span class="br0">(</span>parent<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> ~GLWidget<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">private</span><span class="sy4">:</span>
  <span class="co1">// Les 3 méthodes clés de la classe QGLWidget à réimplémenter</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> initializeGL<span class="br0">(</span><span class="br0">)</span>                  override<span class="sy4">;</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> resizeGL<span class="br0">(</span><span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">)</span> override<span class="sy4">;</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> paintGL<span class="br0">(</span><span class="br0">)</span>                       override<span class="sy4">;</span>
&nbsp;
  <span class="co1">// Un shader OpenGL encapsulé dans une classe Qt</span>
  QGLShaderProgram prog<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif // GLWIDGET_H</span></pre><p>contient essentiellement 4 éléments :</p>
<ul>
  <li><p>un « shader » (expliqué <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#shader">plus haut</a>) ;</p>
  </li>
  <li><p>et 3 méthodes pour gérer différents évènements :</p>
  <ul>
    <li><code>initializeGL</code> pour ce qui doit être fait à l'initialisation de notre scène OpenGL&nbsp;;
</li>
    <li><code>resizeGL</code> qui sera appelée si la fenêtre est redimensionnée&nbsp;;
</li>
    <li>et <code>paintGL</code> qui sera appelée à chaque fois qu'il est nécessaire de (re)dessiner la scène. C'est donc bien là que nous allons écrire le code de notre dessin.
</li>
</ul></li>
</ul>

<p> Commençons donc par la méthode de dessin&nbsp;: cela se fait en
      ajoutant les lignes suivantes à la classe
      <code>GLWidget</code> <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/glwidget.cc">(fichier <code class="file">glwidget.cc</code></a>, donc)&nbsp;: </p>

<pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">paintGL</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// On commence par effacer ce qu'il y avait à l'écran</span>
  glClear<span class="br0">(</span>GL_COLOR_BUFFER_BIT <span class="sy3">|</span> GL_DEPTH_BUFFER_BIT<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Puis on crée une matrice identitée (constructeur par défaut)
   * que l'on multiplie à droite par une matrice de translation
   * avec comme vecteur de translation (0,0,-2).
   * Finalement, on envoie cette matrice au shader.
   * 
   * Sur notre shader (voir les sources .glsl), il y a deux matrices
   * projection et vue_modele.
   * Les sommets dessinés seront multipliés par la matrice vue_modele
   * puis par projection avant d'être dessiné sur l'écran.
   */</span>
  QMatrix4x4 matrice<span class="sy4">;</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"vue_modele"</span>, matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// On dessine un joli triangle coloré</span>
  glBegin<span class="br0">(</span>GL_TRIANGLES<span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// rouge</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId,  <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// vert</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId,  <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// bleu</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId,  <span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
<p>La première ligne (<code>glClear(...);</code>) permet simplement de repartir sur un nouveau dessin.</p>

<p>Les trois lignes suivantes « placent le point de vue » au point (0,0,2) en passant la matrice de la scène au shader (détaillé plus bas). En fait, on place la scène à dessiner en (0,0,-2). Il faut savoir que l'on regarde toujours depuis (0,0,0) dans la direction (0,0,-1). Ce sont les (sommets des) objets de la scène qui sont déplacés par les opérations géométriques représentées par les matrices 4x4.</p>

<p>Viennent ensuite les lignes qui font effectivement le dessin du triangle :</p>
<ul>
  <li><p>on commence pour cela par dire que l'on veut dessiner une « facette » triangle (c.-à-d. que les 3 point suivants seront reliés par des traits, c'est cette instruction « <code>glBegin(GL_TRIANGLES);</code> » qui dit à OpenGL de relier entre-eux les 3 prochains points ; voir plus bas pour d'autres directives de dessin)&nbsp;;</p>
  </li>
  <li><p>on dessine ensuite consécutivement trois points en indiquant <strong>d'abord</strong> la couleurs associée au point, puis seulement <em>ensuite</em> où se place le point&nbsp;; il est important de <em>terminer</em> le dessin d'un point par l'instruction qui affecte (<code>setAttributeValue</code>) le <code>SommetId</code>&nbsp;;</p>
  <ul>
    <li>la couleur (identifiée par <code>CouleurId</code>) est spécifiée en indiquant trois nombres compris entre 0 et 1 correspondant respectivement au degré de rouge, de vert et de bleu ; ainsi
    <ul>
      <li><code>(1.0, 0.0, 0.0)</code> correspond à la couleur rouge,</li>
      <li><code>(0.0, 1.0, 0.0)</code> correspond à la couleur verte,</li>
      <li><code>(0.0, 0.0, 1.0)</code> correspond à la couleur bleue,</li>
      <li><code>(0.0, 0.0, 0.0)</code> correspond au noir,</li>
      <li><code>(1.0, 1.0, 1.0)</code> au blanc,</li>
      <li><code>(0.5, 0.5, 0.5)</code> à un gris à 50%,</li>
      <li>et par exemple <code>(0.75, 0.0, 0.75)</code> à un violet à 75%&nbsp;;</li>
</ul>
</li>
<li><p>les cordonnées d'un point (identifié par <code>SommetId</code>) sont dans l'ordre usuel (x,y,z); on a donc dans cet exemple mis le point de vue en (0,0,2) [voir plus haut] puis dessiné dans l'ordre un point rouge en (0,0,0), un point vert en (1,0,0) et un point bleu en (1,1,0)&nbsp;;</p>

<p>chaque sommet a une position codée dans un vecteur à 4 composantes (la quatrième composantes est toujours fixée à 1 c'est pourquoi elle n'apparait pas dans le code) puis on multiplie la matrice de dimention 4x4 avec le vecteur pour obtenir la position finale du sommet ;<br> pourquoi en dimention 4 ?<br>  la quatrième coordonnée sert à représenter les translations ; pour plus de détail voir <a href="http://fr.wikipedia.org/wiki/Coordonn%C3%A9es_homog%C3%A8nes#Notation_matricielle">les coordonnées homogènes</a></p>

</li>
</ul></li>
  <li><p>on termine enfin en indiquant à OpenGL que c'est ici que se termine le dessin du triangle (<code>glEnd();</code>) </p></li>
</ul>

<p>Voilà pour l'essentiel de cette méthode de dessin. Nous donnons encore ici quelques compléments techniques qui peuvent être sautés dans une première approche. Si cela ne vous intéresse pas, vous pouvez <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#suite1">continuer ici</a>.</p>

<p>Nous avons ci-dessus utilisé la directive OpenGL <code>GL_TRIANGLES</code>. On peut aussi utiliser <code>GL_QUADS</code> pour des quadrilatères (utile pour des cubes, par exemple) ou simplement <code>GL_LINES</code> pour des lignes.</p>

<p>Ensuite, le code expliqué ci-dessus est assez simple. Il fonctionne car nous avons programmé pour vous un « shader » qui fonctionne avec simplement 2 paramètres : une couleur et un point. Ce shader est décomposé en 2 parties écrites dans les fichiers <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/vertex_shader.glsl"><code class="file">vertex_shader.glsl</code></a> et <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/fragment_shader.glsl"><code class="file">fragment_shader.glsl</code></a> fournis.</p>
<p>Le liens entre ces codes GLSL et notre programme C++ est fait, d'une part au travers du fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/vertex_shader.h"><code class="file">vertex_shader.h</code></a> pour les définitions des identifiants de couleur (<code>CouleurId</code>) et de point (<code>SommetId</code>), et d'autre part au travers de l'attribut <code>prog</code> (voir <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/glwidget.h"><code class="file">glwidget.h</code></a>) qui sera lié aux fichiers GLSL précédents dans la méthode d'initialisation <code>initializeGL</code>.</p>

<p>La méthode <code>resizeGL</code> ensuite :</p>
<pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">resizeGL</span><span class="br0">(</span><span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* On commence par dire sur quelle partie de la 
   * fenêtre OpenGL doit dessiner.
   * Ici on lui demande de dessiner sur toute la fenêtre.
   */</span>
  glViewport<span class="br0">(</span><span class="nu0">0</span>, <span class="nu0">0</span>, width, height<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Puis on modifie la matrice de projection du shader.
   * Pour ce faire on crée une matrice identité (constructeur 
   * par défaut), on la multiplie par la droite par une matrice
   * de perspective.
   * Plus de détail sur cette matrice
   *     http://www.songho.ca/opengl/gl_projectionmatrix.html
   * Puis on upload la matrice sur le shader avec la méthode
   * setUniformValue
   */</span>
  QMatrix4x4 matrice<span class="sy4">;</span>
  matrice.<span class="me1">perspective</span><span class="br0">(</span><span class="nu16">70.0</span>, qreal<span class="br0">(</span>width<span class="br0">)</span> <span class="sy2">/</span> qreal<span class="br0">(</span>height <span class="sy4">?</span> height <span class="sy4">:</span> <span class="nu16">1.0</span><span class="br0">)</span>, <span class="nu19">1e-3</span>, <span class="nu19">1e5</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"projection"</span>, matrice<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p>Cette méthode est appelée lorsque la fenêtre est redimensionnée. Nous choisissons simplement ici de changer la perspective utilisée pour garder les proportions de la fenêtre (c.-à-d. si la fenêtre est agrandie dans une direction, nous agrandissons de même le dessin). Nous faisons ceci en recalculant la matrice de projection utilisée par le shader.</p>
<p>Vous n'aurez pas à changer cette méthode et pouvez donc la reprendre telle quelle sans en comprendre les détails.</p>

<p>La méthode <code>initializeGL</code>, enfin, est très technique et ne devra pas non plus être modifiée. Vous pouvez donc
aussi ignorer ses détails.</p>
<p>Pour en expliquer l'essentiel :</p>
<pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">initializeGL</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* Initialise notre vue OpenGL.
   * Dans cet exemple, nous créons et activons notre shader.
   *
   * En raison du contenu des fichiers *.glsl, le shader de cet exemple
   * NE permet QUE de dessiner des primitives colorées 
   * (pas de textures, brouillard, reflets de la lumière ou autres).
   *
   * Il est séparé en deux parties VERTEX et FRAGMENT.
   * Le VERTEX :
   * - récupère pour chaque sommet des primitives de couleur (dans
   *     l'attribut couleur) et de position (dans l'attribut sommet)
   * - multiplie l'attribut sommet par les matrices 'vue_modele' et
   *     'projection' et donne le résultat à OpenGL
   *   - passe la couleur au shader FRAGMENT.
   *
   * Le FRAGMENT :
   *   - applique la couleur qu'on lui donne
   */</span>
&nbsp;
  prog.<span class="me1">addShaderFromSourceFile</span><span class="br0">(</span>QGLShader<span class="sy4">::</span><span class="me2">Vertex</span>,   <span class="st0">":/vertex_shader.glsl"</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">addShaderFromSourceFile</span><span class="br0">(</span>QGLShader<span class="sy4">::</span><span class="me2">Fragment</span>, <span class="st0">":/fragment_shader.glsl"</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Identifie les deux attributs du shader de cet exemple
   * (voir vertex_shader.glsl).
   *
   * L'attribut identifié par 0 est particulier, il permet d'envoyer un
   * nouveau "point" à OpenGL
   * 
   * C'est pourquoi il devra obligatoirement être spécifié et en dernier 
   * (après la couleur dans cet exemple, voir plus bas).
   */</span>
&nbsp;
  prog.<span class="me1">bindAttributeLocation</span><span class="br0">(</span><span class="st0">"sommet"</span>,  SommetId<span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">bindAttributeLocation</span><span class="br0">(</span><span class="st0">"couleur"</span>, CouleurId<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Compilation du shader OpenGL</span>
  prog.<span class="me1">link</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Activation du shader</span>
  prog.<span class="me1">bind</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Activation du "Test de profondeur" et du "Back-face culling"
   * Le Test de profondeur permet de dessiner un objet à l'arrière-plan
   * partielement caché par d'autres objets.
   * 
   * Le Back-face culling consiste à ne dessiner que les face avec ordre 
   * de déclaration dans le sens trigonométrique.
   */</span>
  glEnable<span class="br0">(</span>GL_DEPTH_TEST<span class="br0">)</span><span class="sy4">;</span>
  glEnable<span class="br0">(</span>GL_CULL_FACE<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><ul>
  <li><p>nous ajoutons notre shader (en 2 parties) dans l'attribut <code>prog</code> de notre instance de la classe <code>GLWidget</code> ;</p>
  </li>
  <li><p>nous associons les identifiants C++ choisis (<code>CouleurId</code> et <code>SommetId</code>) aux parties correspondantes du shader (lien entre le C++, dans le CPU, et le GLSL, dans le GPU) ;</p></li>
  <li><p>puis nous compilons le code GLSL et l'envoyons sur le GPU ;</p></li>
  <li><p>enfin, nous initialisons quelques comportements voulus pour le rendu OpenGL.</p></li>
</ul>
<p>Voilà donc pour tout ce code, dont, encore une fois, il n'est pas nécessaire de comprendre les détails, beaucoup de choses vous étant fournies afin de faciliter la prise en main et la mise en œuvre du graphisme.</p>

<a name="suite1"></a>
<p>Pour compiler tout ceci, il faut d'abord générer le <code class="file">Makefile</code>, ce qui se fait en lançant la commande <code>qmake</code> qui lit <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/ex_01.pro">le fichier « <code>.pro</code> » suivant</a> :</p>
<pre class="cpp"><span class="co2">#</span>
<span class="co2"># Ce fichier est lu par le programme qmake pour générer le Makefile</span>
<span class="co2">#</span>
&nbsp;
QT             <span class="sy2">+</span><span class="sy1">=</span> core gui opengl
QMAKE_CXXFLAGS <span class="sy2">+</span><span class="sy1">=</span> <span class="sy2">-</span>std<span class="sy1">=</span>c<span class="sy2">++</span><span class="nu0">11</span>
&nbsp;
greaterThan<span class="br0">(</span>QT_MAJOR_VERSION, <span class="nu0">4</span><span class="br0">)</span><span class="sy4">:</span> QT <span class="sy2">+</span><span class="sy1">=</span> widgets
&nbsp;
TARGET   <span class="sy1">=</span> ex_01
TEMPLATE <span class="sy1">=</span> app
&nbsp;
SOURCES <span class="sy2">+</span><span class="sy1">=</span> \
    main_qt_gl.<span class="me1">cc</span> \
    glwidget.<span class="me1">cc</span>
&nbsp;
HEADERS <span class="sy2">+</span><span class="sy1">=</span> \
    glwidget.<span class="me1">h</span> \
    vertex_shader.<span class="me1">h</span>
&nbsp;
RESOURCES <span class="sy2">+</span><span class="sy1">=</span> \
    resource.<span class="me1">qrc</span></pre><p>Là non plus, pas besoin de tout comprendre. Ce qu'il faut savoir c'est que :</p>

<ul>
  <li><p>La variable <code>TARGET</code> doit contenir le nom de l'exécutable final (au choix) ;</p>
  </li>
  <li><p><code>SOURCES</code> contient la liste des fichiers C++ (« <code>.cc</code> » ou « <code>.cpp</code> ») nécessaires ;</p></li>
  <li><p><code>HEADERS</code> contient la liste des fichiers « <code>.h</code> » utilisés ;</p></li>
  <li><p>et <code>RESOURCES</code> doit rester comme ceci. Il indique où se trouvent les shaders utilisés.</p>
  <p>Le fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/resource.qrc"></a><code class="file">resource.qrc</code> est fourni et n'aura pas à être modifié.</p></li>
</ul>

<p>Si tout se passe bien (<code>qmake &amp;&amp; make &amp;&amp; ./ex_01</code>) vous devriez voir un joli triangle coloré !</p>
  
<!-- ToC -->

    <a name="exmpl2" id="exmpl2"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>

          <ul class="subnavlist">
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Concepts de base</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">Premier dessin</a>
            </li>
            <li class="subactive">

              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl2">Conception</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl3">Plusieurs objets</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">Point de vue et gestion clavier</a>

            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>

        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h3>
      Deuxième exemple&nbsp;: réorganisation du code, meilleure conception, et dessin d'un cube
    </h3>

<p>Notre exemple simple précédent nécessite déjà 8 fichiers :</p>
    <ol>
      <li><p>le fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/main_qt_gl.cc"><code>main_qt_gl.cc</code></a>, qui contient le <code>main()</code> [que vous pourrez reprendre à l'identique]&nbsp;;</p>
      </li>
      <li><p><a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/glwidget.h"><code>glwidget.h</code></a>, qui contient la description de la classe principale pour dessiner (fenêtre principale)&nbsp;;</p>
      </li>
      <li><p><a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/glwidget.cc"><code>glwidget.cc</code></a>, qui contient les définitions des méthodes de cette classe (méthodes de dessin)&nbsp;;</p>
      </li>
      <li><p><a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/vertex_shader.h"><code>vertex_shader.h</code></a>, qui fait le lien entre les conventions du shader utilisées et celles de nos programmes C++&nbsp;;</p>
      </li>
      <li><p><a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/vertex_shader.glsl"><code>vertex_shader.glsl</code></a>, première partie du shader&nbsp;, executée en parallèle une fois par sommet;</p>
      </li>
      <li><p><a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/fragment_shader.glsl"><code>fragment_shader.glsl</code></a>, seconde partie du shader &nbsp;, executée aussi en parallèle mais cette fois une fois par pixel;</p>
      </li>
      <li><p><a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/resource.qrc"><code>resource.qrc</code></a>, qui décrit à Qt les ressources utilisées, c'est à dire les fichiers à insérer dans l'executable (shader, dans notre cas)&nbsp;, c'est typiquement dans ce fichier qu'on rajouterait l'image de l'icone de l'application;</p>
      </li>
      <li><p>et enfin le fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_01/ex_01.pro"><code>ex_01.pro</code></a> qui permet facilement de compiler tout ça grâce à <code>qmake</code>.</p>
      </li>
    </ol>
<p>C'est déjà pas mal&nbsp;!
Mais c'est un peu trop simple, pas assez modularisé, pour un projet comme le nôtre.</p>    
    <p>L'idée de cette partie du tutoriel est d'avoir une conception générale et modulaire pour tout projet graphique comportant d'un coté un système à simuler (et visualiser) et de l'autre une interface de visualisation.</p><p>Nous allons organiser notre application (notre programme final) suivant deux grands principes (techniquement on appelle cela des « design patterns ») :</p>
    <ul>
      <li><p>clairement séparer trois choses : la gestion de notre application (le <code>main()</code> si vous voulez, ou notre <code>GLWidget</code>), le contenu à afficher et la façon de l'afficher ; cette dernière pouvant être sous différentes formes : soit format texte, soit écriture dans un fichier (non présenté dans ce tutoriel), soit affichage à l'écran, là aussi de diverses façons possibles ;</p>
      </li>
      <li>et donc, justement -- deuxième principe -- clairement séparer ce qui doit être affiché (le « contenu » ci-dessus) de toutes les différentes façons de le faire, celles-ci ne devant pas interférer avec le contenu lui-même.</li>
    </ul>
<p>Voilà pour le programme de cette partie ! Comment faire ?</p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_02.zip">télécharger ici le code de ce deuxième
      exemple</a>.
    </p>

    <p class="note">[ Nous vous expliquons ici la démarche suivie, mais vous pouvez simplement réutiliser l'essentiel du code fourni sans en comprendre tous les détails. ]</p>
    
<p>Commençons par séparer notre programme en plusieurs parties, 3 dans notre cas, mais cela pourrait être plus  :</p>
    <ul>
      <li><p>une partie générale qui contient tout le code indépendant d'un mode de visualisation particulier ; tout le « contenu » donc ;</p>
      </li>
      <li><p>et ensuite autant de parties que de façons de visualiser le contenu. Dans le cadre de ce tutoriel, nous n'en considérerons que deux : le format texte (sur <code>cout</code>, comme d'habitude) et le format graphique avec Qt et OpenGL.</p>
      </li>
    </ul>

 <p>Nous créons donc 3 répertoires, par exemple : <code>general</code>, <code>Qt_GL</code> et <code>text</code>. Commençons par mettre tout notre code précédent (les 8 fichiers) dans <code>Qt_GL</code> et essayons d'ajouter une visualisation en mode texte de notre exemple.</p>

    <p>Il faut pour cela conceptualiser, concevoir, un peu notre application : nous dirons que nous avons un <code>Contenu</code> qui <strong style="text-decoration: underline">est</strong> <code>Dessinable</code>.</p>
    <p>Pour bien séparer les différents moyens de visualisation, nous dirons que tout <code>Dessinable</code> possède un <code>SupportADessin</code>, qui représentera la façon choisie pour dessiner (écran mode texte, mode graphique avec telle bibliothèque, ou telle autre (Qt chez nous), dans un fichier, etc.).</p>
    <p>Nous créons donc les 3 classes suivantes (dans <code>general</code>)</p>

    <ul>
      <li><p><code>Dessinable</code> (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/general/dessinable.h"><code class="file">dessinable.h</code></a>) :</p>
      <pre class="cpp"><span class="co2">#ifndef DESSINABLE_H</span>
<span class="co2">#define DESSINABLE_H</span>
&nbsp;
<span class="kw2">class</span> SupportADessin<span class="sy4">;</span>
&nbsp;
<span class="kw2">class</span> Dessinable <span class="br0">{</span>
 <span class="kw2">public</span><span class="sy4">:</span>
  Dessinable<span class="br0">(</span>SupportADessin<span class="sy2">*</span> support<span class="br0">)</span>
    <span class="sy4">:</span> support<span class="br0">(</span>support<span class="br0">)</span>
  <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> ~Dessinable<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> dessine<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
&nbsp;
 <span class="kw2">protected</span><span class="sy4">:</span>
  <span class="coMULTI">/* Nous mettons un pointeur au lieu d'une référence *
   * au cas où l'on voudrait changer de support (non  *
   * implémenté ici), ou même copier un dessinable,   *
   * échanger (swap) deux dessinables, etc.           *
   * Il n'est pas nécessaire d'implémenter une copie  *
   * profonde ici ; c'est bien une copie de surface   *
   * dont nous avons besoin.                          */</span>
  SupportADessin<span class="sy2">*</span> support<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif</span></pre>      </li>
      <li><p><code>SupportADessin</code> (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/general/support_a_dessin.h"><code class="file">support_a_dessin.h</code></a>) :</p>
      <pre class="cpp"><span class="co2">#ifndef SUPPORT_A_DESSIN_H</span>
<span class="co2">#define SUPPORT_A_DESSIN_H</span>
&nbsp;
<span class="kw2">class</span> Contenu<span class="sy4">;</span>
&nbsp;
<span class="kw2">class</span> SupportADessin
<span class="br0">{</span>
 <span class="kw2">public</span><span class="sy4">:</span>
  <span class="kw2">virtual</span> ~SupportADessin<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
  <span class="kw2">virtual</span> <span class="kw4">void</span> dessine<span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Mettre ici toutes les méthodes nécessaires pour dessiner tous les
   * objets que l'on veut dessiner. Par exemple :
   *    virtual void dessine(Nounours const&amp; a_dessiner) = 0;
   *    virtual void dessine(Voiture  const&amp; a_dessiner) = 0;
   */</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif</span></pre>      </li>
      <li><p>et <code>Contenu</code> (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/general/contenu.h"><code class="file">contenu.h</code></a>) :</p>
      <pre class="cpp"><span class="co2">#ifndef CONTENU_H</span>
<span class="co2">#define CONTENU_H</span>
&nbsp;
<span class="co2">#include "dessinable.h"</span>
<span class="co2">#include "support_a_dessin.h"</span>
&nbsp;
<span class="kw2">class</span> Contenu <span class="sy4">:</span> <span class="kw2">public</span> Dessinable <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  Contenu<span class="br0">(</span>SupportADessin<span class="sy2">*</span> vue<span class="br0">)</span>
    <span class="sy4">:</span> Dessinable<span class="br0">(</span>vue<span class="br0">)</span>
  <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> ~Contenu<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
  <span class="kw2">virtual</span> <span class="kw4">void</span> dessine<span class="br0">(</span><span class="br0">)</span> override
  <span class="br0">{</span> support<span class="sy2">-</span><span class="sy1">&gt;</span>dessine<span class="br0">(</span><span class="sy2">*</span><span class="kw3">this</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif // CONTENU_H</span></pre>      </li>
    </ul>

    <p>L'aspect technique dans ce code, qui dépasse un peu le niveau de ce cours, est la méthode <code>dessine</code> de la classe <code>Contenu</code>. <strong>TOUTES</strong> les classes dessinables devront avoir cette <em>même</em> méthode, exactement la même, pour pouvoir être correctement dessinées par le « support à dessin » correspondant.<br> (Techniquement il s'agit ici de ce que l'on appelle en programmation le « <em>double dispatch</em> », une généralisation du polymorphisme : nous avons ici un comportement polymorphique à 2 paramètres : ce qui doit être dessiné (le contenu) et ce sur quoi (ou comment) il doit être dessiné (le « support à dessin »)).
    </p>

    <p>Nous avons fini pour cet exemple avec la partie générale, abstraite.<br> Passons à la visualisation en mode texte.</p>
    <p>Nous allons pour cela créer le <code>SupportADessin</code> correspondant. Appelons-le <code>TextViewer</code>. L'idée est d'avoir ensuite simplement le <code>main()</code> suivant (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/text/main_text.cc">fichier <code>main_text.cc</code></a>) :</p>
      <pre class="cpp"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include "text_viewer.h"</span>
<span class="co2">#include "contenu.h"</span>
<span class="kw2">using</span> <span class="kw2">namespace</span> std<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* Nous voulons un support à dessin :                          *
   * ici un TextViewer qui écrit sur cout                        */</span>
  TextViewer ecran<span class="br0">(</span><span class="kw3">cout</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Nous voulons un contenu à dessiner, et que ce contenu       *
   * se dessine sur notre support à dessin précédent             */</span>
  Contenu c<span class="br0">(</span><span class="sy3">&amp;</span>ecran<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Nous dessinons notre contenu</span>
  c.<span class="me1">dessine</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
<p>Pour généraliser un peu, imaginons que cette classe  <code>TextViewer</code> puisse « choisir » le flot dans lequel elle veut écrire. Nous lui ajoutons donc simplement une référence sur un flot et avons donc le code suivant (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/text/text_viewer.h">fichier <code>text_viewer.h</code></a>) :</p>
      <pre class="cpp"><span class="co2">#ifndef TEXT_VIEWER_H</span>
<span class="co2">#define TEXT_VIEWER_H</span>
&nbsp;
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include "support_a_dessin.h"</span>
&nbsp;
<span class="kw2">class</span> TextViewer <span class="sy4">:</span> <span class="kw2">public</span> SupportADessin <span class="br0">{</span>
 <span class="kw2">public</span><span class="sy4">:</span>
 TextViewer<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">ostream</span><span class="sy3">&amp;</span> flot<span class="br0">)</span>
    <span class="sy4">:</span> flot<span class="br0">(</span>flot<span class="br0">)</span>
  <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> ~TextViewer<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
  <span class="kw2">virtual</span> <span class="kw4">void</span> dessine<span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span> override<span class="sy4">;</span>
&nbsp;
 <span class="kw2">private</span><span class="sy4">:</span>
  std<span class="sy4">::</span><span class="me2">ostream</span><span class="sy3">&amp;</span> flot<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif</span></pre>
<p>L'aspect technique à comprendre ici est que nous devrons lui ajouter autant de méthodes <code>dessine</code> que nous avons de sortes objets différents (i.e. de classes) à dessiner. Ici nous ne voulons dessiner qu'une seule sorte d'objets, les <code>Contenu</code>s ; nous n'avons donc qu'une seule méthode <code>dessiner</code> dans cette classe.</p>

<p>Il ne reste donc plus qu'à écrire comment dessiner notre contenu. Décidons pour cela de simplement « dessiner » un cube en mode texte en affichant simplement le message : « un cube ». Ce qui conduit au code suivant (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/text/text_viewer.h">fichier <code>text_viewer.cc</code></a>) :</p>
      <pre class="cpp"><span class="co2">#include &lt;iostream&gt; // pour endl</span>
<span class="co2">#include "text_viewer.h"</span>
<span class="co2">#include "contenu.h"</span>
&nbsp;
<span class="kw4">void</span> TextViewer<span class="sy4">::</span><span class="me2">dessine</span><span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* Dans ce premier exemple très simple, on n'utilise       *
   * pas l'argument Contenu. Nous ne l'avons donc pas nommé. */</span>
&nbsp;
  flot <span class="sy1">&lt;&lt;</span> <span class="st0">"un cube"</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
<p>Si ce n'est pas déjà fait, vous pouvez déjà compiler cette partie à l'aide des fichiers « <code>.pro</code> » fournis (que nous ne détaillerons pas ici) : dans le répertoire <code>ex_02</code>, faire simplement</p>
<pre>qmake
make
./text/ex_02_text
</pre>

<p>Passons maintenant à la partie graphique. Il suffit de réorganiser notre exemple précédent suivant la nouvelle conception. Nous devons pour cela séparer dans notre ancienne classe <code>GLWidget</code> les parties « application principale », « contenu » et « support à dessin ».</p>
<p>Pour le contenu, c'est simple, c'est déjà fait (<code>contenu.h</code>). Il suffit juste de dire que la classe <code>GLWidget</code> <strong>a</strong>/<strong>possède</strong> un contenu à dessiner (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/glwidget.h">fichier <code>glwidget.h</code></a>, ligne 30) :</p>
<pre class="cpp">&nbsp;
  <span class="co1">// objets à dessiner</span>
<span class="xtra ln-xtra">  Contenu c<span class="sy4">;</span></span>
<span class="br0">}</span><span class="sy4">;</span></pre>
<p>Pour le support à dessin, c'est presque aussi simple : c'est notre shader qui va jouer ce rôle. Il nous faut « simplement » l'habiller (l'encapsuler) en un <code>SupportADessin</code>. Techniquement, nous ajoutons juste quelques méthodes-outils supplémentaires pour faciliter son utilisation, ce qui conduit au code suivant (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/vue_opengl.h">fichier <code>vue_opengl.h</code></a>) :</p>
      <pre class="cpp"><span class="co2">#ifndef VUEOPENGL_H</span>
<span class="co2">#define VUEOPENGL_H</span>
&nbsp;
<span class="co2">#include &lt;QGLShaderProgram&gt; // Classe qui regroupe les fonctions OpenGL liées aux shaders</span>
<span class="co2">#include &lt;QMatrix4x4&gt;</span>
<span class="co2">#include "support_a_dessin.h"</span>
&nbsp;
<span class="kw2">class</span> VueOpenGL <span class="sy4">:</span> <span class="kw2">public</span> SupportADessin <span class="br0">{</span>
 <span class="kw2">public</span><span class="sy4">:</span>
  <span class="co1">// méthode(s) de dessin (héritée(s) de SupportADessin)</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> dessine<span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span> override<span class="sy4">;</span>
&nbsp;
  <span class="co1">// méthode d'initialisation</span>
  <span class="kw4">void</span> init<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// méthode set</span>
  <span class="kw4">void</span> setProjection<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> projection<span class="br0">)</span>
  <span class="br0">{</span> prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"projection"</span>, projection<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
  <span class="co1">// méthode utilitaire offerte pour simplifier</span>
  <span class="kw4">void</span> dessineCube<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue <span class="sy1">=</span> QMatrix4x4<span class="br0">(</span><span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span>
&nbsp;
 <span class="kw2">private</span><span class="sy4">:</span>
  <span class="co1">// Un shader OpenGL encapsulé dans une classe Qt</span>
  QGLShaderProgram prog<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif</span></pre>
<p>Il nous faut aussi :</p>
<ul>
  <li><p>dire que la classe <code>GLWidget</code> <strong>a</strong>/<strong>possède</strong> maintenant une <code>VueOpenGL</code> au lieu du shader directement (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/glwidget.h">fichier <code>glwidget.h</code></a>, ligne 27) :</p>
<pre class="cpp">  <span class="co1">// Vue : ce qu'il faut donner au contenu pour qu'il puisse se dessiner sur la vue</span>
<span class="xtra ln-xtra">  VueOpenGL vue<span class="sy4">;</span></span></pre></li>
<li><p>initialiser le support à dessin de notre contenu dans le constructeur de <code>GLWidget</code> (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/glwidget.h">fichier <code>glwidget.h</code></a>, ligne 16) :</p>
<pre class="cpp">  GLWidget<span class="br0">(</span>QWidget<span class="sy2">*</span> parent <span class="sy1">=</span> nullptr<span class="br0">)</span>
    <span class="sy4">:</span> QGLWidget<span class="br0">(</span>parent<span class="br0">)</span>
<span class="xtra ln-xtra">    , c<span class="br0">(</span><span class="sy3">&amp;</span>vue<span class="br0">)</span></span>
  <span class="br0">{</span><span class="br0">}</span></pre></li>
<li><p>et déplacer le code nécessaire de <code>GLWidget</code> vers <code>VueOpenGL</code> (fichiers <a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/glwidget.cc"><code>glwidget.cc</code></a> et <a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>).</p></li>
</ul>

<p>Terminons cette partie en changeant de dessin pour notre contenu : dessinons maintenant un cube avec des faces colorées, au lieu d'un triangle.</p>
<p>Comme pour le support à dessin « mode texte », cela se fait dans la méthode <code>dessine</code> correspondant au support à dessin et à l'objet à dessiner voulus ; plus clairement ici : dans la méthode <code>dessine(Contenu)</code> du support à dessin <code>VueOpenGL</code>.</p>

<p>Nous décomposons pour cela le dessin en 2 parties :</p>
<ul>
  <li><p>le positionnement du point de vue (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/vue_opengl.cc">fichier <code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessine</span><span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span>
<span class="br0">{</span>
  Q_UNUSED<span class="br0">(</span>a_dessiner<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Dans cet exemple simple, on n'utilise pas le paramètre.</span>
&nbsp;
  <span class="coMULTI">/* Création d'une matrice pour modifier le point de vue.                    *
   * Cette matrice sera appliquée aux 8 sommets du cube.                      *
   * Au départ, la matrice est la matrice identité (constructeur par défaut). */</span>
  QMatrix4x4 matrice<span class="sy4">;</span> 
&nbsp;
  <span class="co1">// Multiplie la matrice à droite par une matrice de translation (0, 0, -4).</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">4.0</span><span class="br0">)</span><span class="sy4">;</span>  
&nbsp;
  <span class="co1">// Multiplie la matrice à droite par une matrice de rotation de 60 degrés autour de l'axe Y.</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">60.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Multiplie la matrice à droite par une matrice de rotation de 45 degrés autour de l'axe Z.</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">45.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> 
&nbsp;
  <span class="co1">// Dessine le cube</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></li>
  <li><p>et le dessin du cube proprement dit (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_02/Qt_GL/vue_opengl.cc">fichier <code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessineCube</span> <span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue<span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// Passe la matrice point_de_vue au shader</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"vue_modele"</span>, point_de_vue<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  glBegin<span class="br0">(</span>GL_QUADS<span class="br0">)</span><span class="sy4">;</span>
  <span class="co1">// face coté X = +1</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// rouge</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// face coté X = -1</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// vert</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// face coté Y = +1</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// bleu</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// face coté Y = -1</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// cyan</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// face coté Z = +1</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// jaune</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// face coté Z = -1</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// magenta</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></li>
</ul>

<p>Pour dessiner le cube, il faut procéder en plusieurs étapes. La
   première consiste à découper ce cube en faces.  En effet OpenGL ne
   peut dessiner que des lignes, triangles ou quadrilatères. On va
   donc découper le cube en six faces carrées (quadrilatères, donc ;
   on utilise la directive <code>GL_QUADS</code>). Chaque face est
   ensuite dessinée en indiquant les coordonnées de chacun de ses
   coins. On peut également au préalable spécifier une couleur pour la
   face.  </p>

<p class="note"> <strong>NOTE 1&nbsp;:</strong> On pourrait également
      spécifier une couleur par sommet, ce qui donne de jolis
dégradés , comme dans le cas de notre premier triangle. Il faut simplement savoir que lorsqu'on fixe une couleur,
tout sera dessiné de cette couleur
      jusqu'au prochain changement de couleur.  </p>

<p class="note">
      <strong>NOTE 2&nbsp;:</strong> Si l'on veut dessiner plusieurs quadrilatères à la suite, on a pas besoin d'appeler chaque fois <code>glBegin()</code> et <code>glEnd()</code>. Une fois au début et à la fin suffit. Il faut juste qu'il y ait le bon nombre de sommets (un multiple de 4).
    </p>

<p>Voilà pour ce second exemple&nbsp;! Ouf !<br>Cela peu paraître un peu fastidieux, surtout pour un dessin aussi simple, mais nous avons maintenant le cadre pour aborder dessiner de plusieurs façons des contenus aussi compliqués que l'on veut : nous n'aurons plus à changer ce cadre mais simplement à le remplir.
    </p>

<!-- ToC -->
    <a name="exmpl3" id="exmpl3"></a>
    <div class="navcontainer">

      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
          <ul class="subnavlist">
            <li>

              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Concepts de base</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">Premier dessin</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl2">Conception</a>

            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl3">Plusieurs objets</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">Point de vue et gestion clavier</a>
            </li>
          </ul>

        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
        </li>
        <li>

          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h3>
      Troisième exemple&nbsp;: dessin de plusieurs objets
    </h3>
    <p>
      Nous abordons maintenant le dessin de plusieurs objets car,
      comme évoqué dans l'introduction générale, cela est peu intuitif la
      première fois et nécessite quelques précautions.
    </p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_03.zip">télécharger ici le code de ce troisième exemple</a>.
    </p>

    <p>Comme nous l'avons vu, pour dessiner un objet, il faut connaître les
      coordonnées de ses sommets. Pour dessiner plusieurs objets, on
      pourrait calculer la position de chacun des sommets de chacun
      des objets «&nbsp;à la main&nbsp;». Mais cela devient très vite fastidieux
      si les objets se déplacent ou si les objets ont des formes
      complexes. De plus, cela ne permet pas de créer du code
      générique. Nous pouvons gérer les positions des
      objets au moyen de matrices ou de «&nbsp;déplacements&nbsp;» (ce n'est pas
      le terme officiel, mais c'est plus intuitif).
    </p>

    <p>Dans l'exemple du cube, nous avions donné les coordonnées des
    sommets par rapport à l'origine. On pourrait donc imaginer
    «&nbsp;déplacer l'origine&nbsp;» pour pouvoir dessiner un nouveau cube à un
    autre endroit. Pour se faire, il existe trois méthodes de la classe <code>QMatrix4x4</code> : </p>
    
    <ul>

      <li><code>translated(x, y, z);</code> qui déplace l'origine vers le
      point (x,y,z) ;</li>
      
	<li><code>rotated(angle, x, y, z)</code> qui fait tourner le
	repère d'un certain angle autour du vecteur
	(x, y, z) ;</li>
	
	<li><code>scaled(facteur)</code> qui dilate l'espace du facteur donné
	 (homothétie).</li>
	
    </ul>

<p class="note"> <strong>NOTE&nbsp;:</strong> En OpenGL, les angles
      sont définis en degrés. Ce qui n'est pas le cas des fonctions C++ de
      <code>cmath</code>, qui sont en radians. Il vous faudra donc convertir les angles de radians à
      degrés et vice-versa si vous voulez utiliser les fonctions
      trigonométriques de <code>cmath</code>.
</p>

    <p>Passons à un exemple : ajoutons 2 petits cubes à notre dessin, l'un au dessus de notre premier cube (axe des y avec le choix de repère que nous avons pris au début de <code>VueOpenGL::dessine</code>)  et l'autre à droite (axe des z avec notre rotation de repère) et tourné de 45 degrés.
    </p>
<p>Pour le premier, il suffit donc d'ajouter (à la méthode <code>dessine</code> de la classe <code>VueOpenGL</code> ; fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_03/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
    <pre class="cpp">  <span class="co1">// Dessine le 2e cube</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">1.5</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// on se déplace de 1.5 au dessus (axe y)</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// on réduit le cube d'un facteur 0.25 (homothétie)</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// et on dessine le cube</span></pre>    <p>(le cube est réduit d'un facteur 0.25 puis translaté en (0, 1.5, 0). Je vous rappelle que les matrices se composent comme les fonctions : l'opération qui est en réalité appliquée en premier est celle écrite en dernier. Ici ce n'est pas important puisque les deux opérations commutent, mais voyez la suite)</p>
    <p>Pour le 3<sup>e</sup>, on procède de façon similaire :</p>
    <pre class="cpp">  <span class="co1">// Dessine le 3e cube</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.5</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// (3) puis on se déplace à droite (axe z)</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span>                 <span class="co1">// (2) puis on réduit la taille</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">45.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// (1) on tourne de 45 degrés</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span></pre>    <p>mais si l'on fait directement de la sorte (essayez !!) : le 3<sup>e</sup> cube sera dessiné par rapport au second cube et non pas par rapport au premier et sera encore plus petit (0.25 x 0.25).</p>
    
    <p> Pour faire ce que l'on veut (le placer par rapport au premier cube), il faut « revenir en arrière » après le dessin du 2<sup>e</sup> cube. Il arrive souvent, que l'on veuille revenir en arrière après
    un déplacement, un dessin. 
      Ce qu'il faut faire pour cela,  c'est simplement
      de sauvegarder la matrice courante au préalable. On peut ensuite se
      positionner (translation , rotation, ...)   au point où l'on souhaite dessiner, puis revenir au point de départ en restaurant la matrice sauvegardée. Dans notre cas cela donne donc le code complet suivant (surlignée, la matrice de sauvegarde intermédiaire) :
    </p>
    <pre class="cpp">  <span class="co1">// Dessine le cube</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
<span class="xtra ln-xtra">  QMatrix4x4 reference<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// sauvegarde le point de vue de référence</span></span>
&nbsp;
  <span class="co1">// Dessine le 2e cube</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">1.5</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// on se déplace de 1.5 au dessus (axe y)</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// on réduit le cube d'un facteur 0.25 (homothétie)</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// et on dessine le cube</span>
&nbsp;
  <span class="co1">// Revient au point de référence</span>
<span class="xtra ln-xtra">  matrice <span class="sy1">=</span> reference<span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// Dessine le 3e cube</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.5</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// (3) puis on se déplace à droite (axe z)</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span>                 <span class="co1">// (2) puis on réduit la taille</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">45.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// (1) on tourne de 45 degrés</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
    <p>Concernant l'ordre des opérations : si l'on inverse rotation et translation du 3<sup>e</sup> cube (essayez !!) : le système d'axes aura d'abord été tourné puis translaté et donc le 3<sup>e</sup> cube ne sera pas déplacé suivant l'axe z de notre repère mais suivant un axe à 45 degrés (i.e. l'axe z=y).</p>

<p>Si l'on veut, on peut aussi modifier l'affichage texte de cet exemple. Cela ne cause aucune difficulté.</p>

<!-- ToC -->
    <a name="exmpl4" id="exmpl4"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li class="active">

          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
          <ul class="subnavlist">
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Concepts de base</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">Premier dessin</a>

            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl2">Conception</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl3">Plusieurs objets</a>
            </li>
            <li class="subactive">

              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">Point de vue et gestion clavier</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li>

          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h3>
      Quatrième exemple&nbsp;: gestion du point de vue et évènements clavier
    </h3>

    <p>
      Nous allons maintenant nous intéresser aux évènements simples
      venant du clavier, par exemple à faire tourner la scène à l'aide des
    flèches du clavier.
    Nous continuons pour cela sur le code de l'exemple précédent.
    

    </p>
    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_04.zip">télécharger ici le code de ce quatrième exemple</a>.
    </p>


    <p> Comme toujours, pour faire une nouvelle tâche, il faut prévoir la fonction/méthode correspondante. Ici,
       les prototypes des méthodes permettant de gérer les évènements sont imposés par la
      bibliothèque.
      </p>

<p>Ajoutons donc la méthode prévue pour gérer les évènements clavier (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_04/Qt_GL/glwidget.h">fichier <code class="file">glwidget.h</code></a>) :</p>    
    <pre class="cpp">  <span class="co1">// Méthodes de gestion d'évènements</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> keyPressEvent<span class="br0">(</span>QKeyEvent<span class="sy2">*</span> event<span class="br0">)</span> override<span class="sy4">;</span></pre>
<p>Il nous faut maintenant définir cette méthode (<a href="http://progmaph.epfl.ch/projet/src/qt/ex_04/Qt_GL/glwidget.cc">fichier <code class="file">glwidget.cc</code></a>).
 Il faut donc, avant cela,
savoir <strong>CE</strong> que l'on veut faire...</p>

<p>Disons donc que nous voulons déplacer le point de vue comme dans les « jeux à la 1<sup>ère</sup> personne » : </p>
    <ul>
      <li><p>les « flèches » tournent l'observateur sur lui-même</p></li>
      <li><p>les touches 'W' et 'S' ou 'Page UP et 'Page Down' font avancer/reculer l'observateur</p></li>
      <li><p>les touches 'A' et 'D' déplacent l'observateur à droite/gauche</p></li>
      <li><p>les touches 'R' et 'F' déplacent l'observateur vers le haut/bas</p></li>
      <li><p>les touches 'Q' et 'E' inclinent la tête de l'observateur vers la droite/gauche</p></li>
      <li><p>enfin ajoutons que la touche 'Home' réinitialise la vue au point de départ.</p></li>
</ul>

<p>Pour cela on commence par définir les deux constantes fixant la taille « d'un pas » et d'une rotation élémentaire :</p>
    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">keyPressEvent</span><span class="br0">(</span>QKeyEvent<span class="sy2">*</span> event<span class="br0">)</span>
<span class="br0">{</span>
<span class="xtra ln-xtra">  constexpr <span class="kw4">double</span> petit_angle<span class="br0">(</span><span class="nu16">5.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// en degrés</span></span>
<span class="xtra ln-xtra">  constexpr <span class="kw4">double</span> petit_pas<span class="br0">(</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span></pre>
<p> Ensuite, il faut récupérer la touche
tapée au clavier via la méthode <code>event-&gt;key()</code>. Il n'y a alors plus
qu'à traiter les différents cas. Utilisons pour cela l'approche modulaire : nous allons créer
de nouvelles méthodes dans le « support à dessin » qui feront tourner/déplacer/réinitaliser la caméra.
Si l'on suppose que de telles méthode existent (et s'appellent
<code>rotate</code>, <code>translate</code> et <code>initializePosition</code>), alors le code de la méthode de gestion des évènements
clavier devient simplement&nbsp;:</p>
    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">keyPressEvent</span><span class="br0">(</span>QKeyEvent<span class="sy2">*</span> event<span class="br0">)</span>
<span class="br0">{</span>
  constexpr <span class="kw4">double</span> petit_angle<span class="br0">(</span><span class="nu16">5.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// en degrés</span>
  constexpr <span class="kw4">double</span> petit_pas<span class="br0">(</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">switch</span> <span class="br0">(</span>event<span class="sy2">-</span><span class="sy1">&gt;</span>key<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Left</span><span class="sy4">:</span>
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Right</span><span class="sy4">:</span>
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle, <span class="nu16">0.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Up</span><span class="sy4">:</span>
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Down</span><span class="sy4">:</span>
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_PageUp</span><span class="sy4">:</span>
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_W</span><span class="sy4">:</span>
    vue.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>,  petit_pas<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_PageDown</span><span class="sy4">:</span>
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_S</span><span class="sy4">:</span>
    vue.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span>petit_pas<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_A</span><span class="sy4">:</span>
    vue.<span class="me1">translate</span><span class="br0">(</span> petit_pas, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_D</span><span class="sy4">:</span>
    vue.<span class="me1">translate</span><span class="br0">(</span><span class="sy2">-</span>petit_pas, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_R</span><span class="sy4">:</span>
    vue.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="sy2">-</span>petit_pas, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_F</span><span class="sy4">:</span>
    vue.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>,  petit_pas, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Q</span><span class="sy4">:</span>
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_E</span><span class="sy4">:</span>
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Home</span><span class="sy4">:</span>
    vue.<span class="me1">initializePosition</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
  <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
  updateGL<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// redessine</span>
<span class="br0">}</span></pre>
<p>Techniquement, il faut simplement ne pas oublier d'appeler la méthode qui redessine la scène : <code>updateGL()</code> (dernière ligne de la méthode)</p>

<p>Reste donc à écrire les méthodes <code>VueOpenGL::rotate</code>, <code>VueOpenGL::translate</code> et <code>VueOpenGL::initializePosition</code> (fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_04/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a> ; pensez aussi à les
prototyper dans la classe, fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_04/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a>).</p>

<p>Pour cela, nous ajoutons d'abord une <code>QMatrice4x4</code> comme attribut à la <code>VueOpenGL</code> afin de mémoriser le point de vue courant, puisqu'il va changer (fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_04/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a>) :
</p>
<pre class="cpp">  <span class="co1">// Caméra</span>
  QMatrix4x4 matrice_vue<span class="sy4">;</span></pre><p>ce qui nous permet donc de définir facilement les méthodes en question :</p>
<pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">initializePosition</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// position initiale</span>
  matrice_vue.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  matrice_vue.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">4.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice_vue.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">60.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice_vue.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">45.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// ======================================================================</span>
<span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">translate</span><span class="br0">(</span><span class="kw4">double</span> x, <span class="kw4">double</span> y, <span class="kw4">double</span> z<span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* Multiplie la matrice de vue par LA GAUCHE.
   * Cela fait en sorte que la dernière modification apportée
   * à la matrice soit appliquée en dernier (composition de fonctions).
   */</span>
  QMatrix4x4 translation_supplementaire<span class="sy4">;</span>
  translation_supplementaire.<span class="me1">translate</span><span class="br0">(</span>x, y, z<span class="br0">)</span><span class="sy4">;</span>
  matrice_vue <span class="sy1">=</span> translation_supplementaire <span class="sy2">*</span> matrice_vue<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// ======================================================================</span>
<span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">rotate</span><span class="br0">(</span><span class="kw4">double</span> angle, <span class="kw4">double</span> dir_x, <span class="kw4">double</span> dir_y, <span class="kw4">double</span> dir_z<span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// Multiplie la matrice de vue par LA GAUCHE</span>
  QMatrix4x4 rotation_supplementaire<span class="sy4">;</span>
  rotation_supplementaire.<span class="me1">rotate</span><span class="br0">(</span>angle, dir_x, dir_y, dir_z<span class="br0">)</span><span class="sy4">;</span>
  matrice_vue <span class="sy1">=</span> rotation_supplementaire <span class="sy2">*</span> matrice_vue<span class="sy4">;</span>
<span class="br0">}</span></pre>
<p>[ la méthode <code>initializePosition</code> correspond simplement au code que nous avions mis au début de la méthode <code>dessiner</code> dans l'exemple précédent. ]</p>

<p>Reste encore à réaménager un peu le reste du code :</p>
<ul>
  <li><p>La méthode <code>dessine</code> devient plus simple puisque l'initialisation a été déplacée et qu'il n'y a plus besoin de mémoriser le point de vue puisque c'est fait dans l'attribut <code>matrice_vue</code>&nbsp;:</p>
  <pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessine</span><span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span>
<span class="br0">{</span>
  Q_UNUSED<span class="br0">(</span>a_dessiner<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// dans cet exemple simple on n'utilise pas le paramètre</span>
&nbsp;
   <span class="co1">// Dessine le 1er cube (à l'origine)</span>
  dessineCube<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  QMatrix4x4 matrice<span class="sy4">;</span>
  <span class="co1">// Dessine le 2e cube</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">1.5</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Dessine le 3e cube</span>
  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.5</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">45.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>  </li>
  <li><p>nous ajoutons un appel à la méthode <code>initializePosition</code> en fin de <code>VueOpenGL::init</code></p></li>
  <li><p>et nous intégrons la matrice de point de vue (<code>matrice_vue</code>) dans le dessin des cubes (méthode <code>VueOpenGL::dessineCube</code>) : </p>
<pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessineCube</span> <span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue<span class="br0">)</span>
<span class="br0">{</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"vue_modele"</span>, matrice_vue <span class="sy2">*</span> point_de_vue<span class="br0">)</span><span class="sy4">;</span></span></pre>  </li>
</ul>
<p>Et voilà !! Vous pouvez maintenant déplacer le point de vue (et enfin aller voir les faces cachées de nos cubes).</p>

<p>A partir de cet exemple nous allons présenter différents ajouts indépendants :</p>

<ul>
     <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl5">Le cinquième exemple</a> ajouter une gestion du mouvement des objets et du temps.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Le sixième exemple</a> présente comment dessiner des sphères.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Le septième exemple</a> gère les déplacement à la souris.</p></li>
      <li><p><a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Le huitième exemple</a> montre comment mettre des textures sur les faces des cubes.</p></li>
</ul> 

<!-- ToC -->
    <a name="simul" id="simul"></a>

    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>

        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
          <ul class="subnavlist">
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Bases</a>
            </li>
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl5">Exemple</a>

            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>

        </li>
      </ul>
    </div>
    <h2>
      Simulation en temps réel
    </h2>
    <h3>
      Un peu de théorie
    </h3>
    <p>
      Le terme «&nbsp;temps réel&nbsp;» représente le fait que le temps (physique)
      qui s'écoule a
      une signification dans le programme. Jusqu'ici dans vos
programmes, l'utilisateur
      pouvait attendre 1 ou 10 minutes à l'invite d'un
      «&nbsp;<code class="code">cin</code>&nbsp;» sans que cela ne change en rien le
      comportement du programme. Dans un processus «&nbsp;temps réel&nbsp;», le
      programme continue par contre de s'exécuter, que
      l'utilisateur agisse ou non. Ceci permet par exemple d'animer
      de façon réaliste les éléments du monde que l'on représente.
    </p>
    <p>
      Considérons le cas d'une balle qu'on lâche depuis une
      certaine hauteur. On pourrait, comme dans l'<a href="http://progmaph.epfl.ch/series/serie4.html#exo2">exercice que vous avez fait au
      premier semestre</a>, calculer à l'avance le temps au bout
      duquel la balle touchera le sol. Mais dans une simulation
      physique en temps réel, on voudrait avoir la position de la
      balle à chaque instant, par exemple pour pouvoir l'afficher.
    </p>
    <p>
      On doit donc pouvoir être capable de décrire à chaque instant
      la nouvelle position de la balle en fonction de la position
      précédente et du temps <code>dt</code> écoulé entre deux calculs.
      Ce temps est simplement le temps que l'ordinateur a mis pour
      calculer et afficher la dernière position.
    </p>

    <p>
      Dans une simulation numérique non temps réel, cet intervalle
      <code>dt</code> est fixé à une valeur arbitraire, aussi petite
      que la précision de calcul voulue le nécessite (voir cours
      d'analyse numérique).
    </p>
    <p>
      Dans un programme «&nbsp;temps réel&nbsp;», c'est par contre la puissance
      de la machine qui détermine la valeur de <code>dt</code>&nbsp;: plus
      la scène est complexe à animer et afficher, plus <code>dt</code>

      sera grand, et plus la simulation sera approximative et
      l'animation saccadée.
    </p>
    <p class="note">
      <strong>NOTE&nbsp;:</strong> La raison pour laquelle on ne fixe
      pas à l'avance l'intervalle <code>dt</code> est qu'on a <em>a
      priori</em> aucune idée du temps que prendra le calcul (et
      l'affichage&nbsp;!) d'une image et, surtout, qu'on n'a aucune
      garantie que ce temps restera constant&nbsp;: plus il y a
      d'éléments à prendre en compte, plus ce temps augmentera. On
      s'en rend bien compte dans certains jeux vidéos&nbsp;:
      lorsqu'il y a un phénomène complexe (e.g. une explosion) ou
      trop d'unités à gérer, c'est le nombre d'images par seconde
      qui diminue et non le temps qui se dilate.
    </p>

    <p>
      Concrètement, <code>dt</code> est donné par un «&nbsp;<em>timer</em>&nbsp;»,
      qui est tout simplement une «&nbsp;minuterie interne&nbsp;» de la
bibliothèque Qt.  Nous utiliserons également un « chronomètre »
pour faire correspondre les temps du timer au temps physique réel.
    </p>
    <p>
      La simulation est donc une boucle qui répète en permanence
      plusieurs étapes, parmi lesquelles&nbsp;:
    </p>
    <ol>

      <li><p>calcul (ou mise à jour)&nbsp;: on détermine l'état suivant du
      système, à partir de l'état courant et du pas de temps
      <code>dt</code>&nbsp;; c'est dans cette phase que dans votre projet interviendront les
      équations de la simulation&nbsp;;</p>
      </li>
      <li><p>affichage à l'écran (ou sur tout autre support à dessin)&nbsp;: on envoie les données vers la carte vidéo (ou sur <code>cin</code> ou dans un
      fichier, etc.)&nbsp;;</p>
      </li>
      <li>gestion des interactions (clavier, souris).
      </li>
    </ol>
    <p>
      En théorie, aucun calcul concernant la simulation n'est à
      effectuer dans ces deux dernières phases.
    </p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> dans Qt, comme dans beaucoup
      d'autres bibliothèques similaires, le programme est
      «&nbsp;<em>averti</em>&nbsp;» qu'il doit procéder à l'une ou l'autre
      étape&nbsp;: c'est ce que l'on appelle de la «&nbsp;<em>programmation
      événementielle</em>&nbsp;» (i.e. «&nbsp;à base d'«&nbsp;<em>évènements</em>&nbsp;»).
    </p>
    <p>
      Enfin, lorsqu'une certaine <em>condition d'arrêt</em> est
      atteinte (e.g. un certain délai dépassé, une précision
      suffisante ou un évènement particulier [e.g. clavier]), on
      arrête simplement le programme. 
    </p>

    <p>
      Passons maintenant à un exemple.
    </p><!-- ToC -->
    <a name="exmpl5" id="exmpl5"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>

        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
          <ul class="subnavlist">
            <li>
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Bases</a>

            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl5">Exemple</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>

        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h3>
      Cinquième exemple : simulation temps réel
    </h3>

    <p>Le but est donc d'introduire une évolution «&nbsp;temps réel&nbsp;» dans
      notre exemple précédent. Nous proposons pour cela de faire tourner
      (simplement, de façon proportionnelle au temps (i.e. mouvement
      circulaire uniforme)) un quatrième cube autour des trois
      autres précédemment dessinés.</p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_05.zip">télécharger ici le code de ce cinquième exemple</a>.
    </p>

    <p> La première chose à faire est donc de prévoir l'élément qui va
      se déplacer, c'est-à-dire écrire l'équation d'évolution du
      contenu.  Nous allons donc devoir ajouter un nouveau fichier
      <code>contenu.cc</code>. Nous n'en avions en effet pas besoin
    jusqu'ici car notre classe <code>Contenu</code> n'était jusque là qu'une « coquille vide »,
    sans vraiment de code ; ce qui n'est bien sûr pas très réaliste...
    </p>
    <p>Prenons un modèle simple pour faire évoluer le contenu : un attribut <code>angle</code>, son accesseur
    (appelé <code>infos()</code> ici) et une méthode <code>evolue</code> pour faire évoluer le contenu d'un pas de temps <code>dt</code>
     (fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/general/contenu.h"><code>contenu.h</code></a>) : </p>
    <pre class="cpp"><span class="co2">#ifndef CONTENU_H</span>
<span class="co2">#define CONTENU_H</span>
&nbsp;
<span class="co2">#include "dessinable.h"</span>
<span class="co2">#include "support_a_dessin.h"</span>
&nbsp;
<span class="kw2">class</span> Contenu <span class="sy4">:</span> <span class="kw2">public</span> Dessinable <span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  Contenu<span class="br0">(</span>SupportADessin<span class="sy2">*</span> vue<span class="br0">)</span>
<span class="xtra ln-xtra">    <span class="sy4">:</span> Dessinable<span class="br0">(</span>vue<span class="br0">)</span>, angle<span class="br0">(</span><span class="nu16">0.0</span><span class="br0">)</span></span>
  <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> ~Contenu<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
  <span class="kw2">virtual</span> <span class="kw4">void</span> dessine<span class="br0">(</span><span class="br0">)</span> override
  <span class="br0">{</span> support<span class="sy2">-</span><span class="sy1">&gt;</span>dessine<span class="br0">(</span><span class="sy2">*</span><span class="kw3">this</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="xtra ln-xtra">  <span class="kw4">void</span> evolue<span class="br0">(</span><span class="kw4">double</span> dt<span class="br0">)</span><span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// accesseur</span>
<span class="xtra ln-xtra">  <span class="kw4">double</span> infos<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> angle<span class="sy4">;</span> <span class="br0">}</span></span>
&nbsp;
<span class="kw2">private</span><span class="sy4">:</span>
<span class="xtra ln-xtra">  <span class="kw4">double</span> angle<span class="sy4">;</span> <span class="coMULTI">/* pour le mouvement ;</span></span>
<span class="coMULTI">&nbsp;                  dans cet exemple, juste une rotation</span>
<span class="coMULTI">&nbsp;                  au cours du temps                    */</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif // CONTENU_H</span></pre>
    <p>Pour l'équation d'évolution, nous prenons un modèle très simple (rotation uniforme, fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/general/contenu.cc"><code>contenu.cc</code></a>) : </p>
    <pre class="cpp"><span class="co2">#include "contenu.h"</span>
&nbsp;
<span class="co1">// ======================================================================</span>
<span class="kw4">void</span> Contenu<span class="sy4">::</span><span class="me2">evolue</span><span class="br0">(</span><span class="kw4">double</span> dt<span class="br0">)</span>
<span class="br0">{</span>
  constexpr <span class="kw4">double</span> omega<span class="br0">(</span><span class="nu16">100.0</span><span class="br0">)</span><span class="sy4">;</span>
  angle <span class="sy2">+</span><span class="sy1">=</span> omega <span class="sy2">*</span> dt<span class="sy4">;</span>
<span class="br0">}</span></pre>
    <p>Le fait d'introduire du code dans le répertoire <code>general</code> nous oblige par contre à changer tous les fichiers <code>.pro</code> et d'en ajouter un, <a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/general/general.pro"><code>general.pro</code></a> ,dans le répertoire <code>general</code>. Le but n'est pas de comprendre ici ce dont il s'agit, utilisez simplement les exemples fournis. Il suffira plus tard simplement d'ajouter vos <code>SOURCES</code> et <code>HEADERS</code> aux fichiers « <code>.pro</code> » correspondants.</p>

<p>Nous avons donc maintenant tout ce qu'il faut pour la simulation. Commençons simplement par sa visualisation texte avec simplement 2 pas de calcul (fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/text/main_text.cc"><code>main_text.cc</code></a>) : </p>
    <pre class="cpp"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include "text_viewer.h"</span>
<span class="co2">#include "contenu.h"</span>
<span class="kw2">using</span> <span class="kw2">namespace</span> std<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  TextViewer ecran<span class="br0">(</span><span class="kw3">cout</span><span class="br0">)</span><span class="sy4">;</span>
  Contenu c<span class="br0">(</span><span class="sy3">&amp;</span>ecran<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Au départ :"</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
  c.<span class="me1">dessine</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  c.<span class="me1">evolue</span><span class="br0">(</span><span class="nu16">0.1</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Après un pas de calcul :"</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
  c.<span class="me1">dessine</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  c.<span class="me1">evolue</span><span class="br0">(</span><span class="nu16">0.1</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw3">cout</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"Après deux pas de calcul :"</span> <span class="sy1">&lt;&lt;</span> endl<span class="sy4">;</span>
  c.<span class="me1">dessine</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p>Il nous faut aussi changer la méthode de visualisation du contenu, c'est-à-dire la méthode <code>TextViewer::dessine(Contenu)</code>
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/text/text_viewer.cc"><code>main_text.cc</code></a>) : </p>
    <pre class="cpp"><span class="co2">#include &lt;iostream&gt; // pour endl</span>
<span class="co2">#include "text_viewer.h"</span>
<span class="co2">#include "contenu.h"</span>
&nbsp;
<span class="kw4">void</span> TextViewer<span class="sy4">::</span><span class="me2">dessine</span><span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span>
<span class="br0">{</span>
  flot <span class="sy1">&lt;&lt;</span> a_dessiner.<span class="me1">infos</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> std<span class="sy4">::</span><span class="me2">endl</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p>Si nécessaire, compilez et exécutez la version texte pour voir comment cela fonctionne.</p>

<p>Passons maintenant à la version graphique, qui est un peu plus compliquée.</p>
<p>Nous commençons par ajouter un « <em>timer</em> » et un chronomètre à la classe <code>GLWidget</code>
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/Qt_GL/glwidget.h">fichier <code class="file">glwidget.h</code></a>) :</p>    
    <pre class="cpp"><span class="co2">#ifndef GLWIDGET_H</span>
<span class="co2">#define GLWIDGET_H</span>
&nbsp;
<span class="co2">#include &lt;QGLWidget&gt;        // Classe pour faire une fenêtre OpenGL</span>
<span class="xtra ln-xtra"><span class="co2">#include &lt;QTime&gt;            // Classe pour gérer le temps</span></span>
<span class="co2">#include "vue_opengl.h"</span>
<span class="co2">#include "contenu.h"</span>
&nbsp;
<span class="kw2">class</span> GLWidget <span class="sy4">:</span> <span class="kw2">public</span> QGLWidget
<span class="coMULTI">/* La fenêtre hérite de QGLWidget ;</span>
<span class="coMULTI">&nbsp;* les événements (clavier, souris, temps) sont des méthodes virtuelles à redéfinir.</span>
<span class="coMULTI">&nbsp;*/</span>
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
  GLWidget<span class="br0">(</span>QWidget<span class="sy2">*</span> parent <span class="sy1">=</span> nullptr<span class="br0">)</span>
    <span class="sy4">:</span> QGLWidget<span class="br0">(</span>parent<span class="br0">)</span>
    , c<span class="br0">(</span><span class="sy3">&amp;</span>vue<span class="br0">)</span>
  <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">virtual</span> ~GLWidget<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">private</span><span class="sy4">:</span>
  <span class="co1">// Les 3 méthodes clés de la classe QGLWidget à réimplémenter</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> initializeGL<span class="br0">(</span><span class="br0">)</span>                  override<span class="sy4">;</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> resizeGL<span class="br0">(</span><span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">)</span> override<span class="sy4">;</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> paintGL<span class="br0">(</span><span class="br0">)</span>                       override<span class="sy4">;</span>
&nbsp;
  <span class="co1">// Méthodes de gestion d'évènements</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> keyPressEvent<span class="br0">(</span>QKeyEvent<span class="sy2">*</span> event<span class="br0">)</span> override<span class="sy4">;</span>
<span class="xtra ln-xtra">  <span class="kw2">virtual</span> <span class="kw4">void</span> timerEvent<span class="br0">(</span>QTimerEvent<span class="sy2">*</span> event<span class="br0">)</span>  override<span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// Méthodes de gestion interne</span>
<span class="xtra ln-xtra">  <span class="kw4">void</span> pause<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// Vue : ce qu'il faut donner au contenu pour qu'il puisse se dessiner sur la vue</span>
  VueOpenGL vue<span class="sy4">;</span>
&nbsp;
  <span class="co1">// Timer</span>
<span class="xtra ln-xtra">  <span class="kw4">int</span> timerId<span class="sy4">;</span></span>
  <span class="co1">// pour faire évoluer les objets avec le bon "dt"</span>
<span class="xtra ln-xtra">  QTime chronometre<span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// objets à dessiner, faire évoluer</span>
  Contenu c<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif // GLWIDGET_H</span></pre><p>et 
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/Qt_GL/glwidget.cc">fichier <code class="file">glwidget.cc</code></a>) :</p>    
    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">initializeGL</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  vue.<span class="me1">init</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  timerId <span class="sy1">=</span> startTimer<span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="sy4">;</span></span>
<span class="br0">}</span></pre>    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">timerEvent</span><span class="br0">(</span>QTimerEvent<span class="sy2">*</span> event<span class="br0">)</span>
<span class="br0">{</span>
  Q_UNUSED<span class="br0">(</span>event<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw4">double</span> dt <span class="sy1">=</span> chronometre.<span class="me1">restart</span><span class="br0">(</span><span class="br0">)</span> <span class="sy2">/</span> <span class="nu16">1000.0</span><span class="sy4">;</span>
&nbsp;
<span class="xtra ln-xtra">  c.<span class="me1">evolue</span><span class="br0">(</span>dt<span class="br0">)</span><span class="sy4">;</span></span>
  updateGL<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p>où l'on voit bien que dans la méthode associée au « <em>timer</em> » nous appelons la méthode d'évolution du contenu.</p>

<p>Reste maintenant à dessiner le cube qui bouge. Cela se fait bien sûr dans la méthode de dessin du contenu, i.e. dans
la méthode <code>VueOpenGL::dessine(Contenu)</code>
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/Qt_GL/vue_opengl.cc">fichier <code class="file">vue_opengl.cc</code></a>) :</p>    
    <pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessine</span><span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span>
<span class="br0">{</span>
   <span class="co1">// Dessine le 1er cube (à l'origine)</span>
  dessineCube<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  QMatrix4x4 matrice<span class="sy4">;</span>
  <span class="co1">// Dessine le 2e cube</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">1.5</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Dessine le 3e cube</span>
  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.5</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.25</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="nu16">45.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Dessine le 4e cube</span>
<span class="xtra ln-xtra">  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span>
<span class="xtra ln-xtra">  matrice.<span class="me1">rotate</span><span class="br0">(</span>a_dessiner.<span class="me1">infos</span><span class="br0">(</span><span class="br0">)</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
<span class="xtra ln-xtra">  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">2.3</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
<span class="xtra ln-xtra">  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.2</span><span class="br0">)</span><span class="sy4">;</span></span>
<span class="xtra ln-xtra">  dessineCube<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span></span>
<span class="br0">}</span></pre>
<p>Notez bien qu'ici la rotation est écrite avant (et donc se fait
après) la translation : c'est bien les axes que nous voulons tourner
ici, et non pas le cube sur lui-même (ce serait simplement un autre
choix : essayez !).</p>

<p>
      Je vous propose pour finir sur ce sujet de rajouter une
      touche pour faire une pause dans la simulation. Comment faire&nbsp;?
    </p>

<p> Il suffit pour cela de suspendre le «&nbsp;timer&nbsp;» à chaque fois qu'une
      pause a été demandée (et de le reprendre lors de la prochaine
      frappe au clavier). Il faut bien sûr associer, dans la fonction
      de gestion des évènements clavier, une touche (par exemple la
      barre espace ici) à cette action
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_05/Qt_GL/glwidget.cc">fichier <code class="file">glwidget.cc</code></a>)&nbsp;:</p>
    <pre class="cpp">  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Home</span><span class="sy4">:</span>
    vue.<span class="me1">initializePosition</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">break</span><span class="sy4">;</span>
&nbsp;
<span class="xtra ln-xtra">  <span class="kw1">case</span> Qt<span class="sy4">::</span><span class="me2">Key_Space</span><span class="sy4">:</span></span>
<span class="xtra ln-xtra">    pause<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span>
<span class="xtra ln-xtra">    <span class="kw1">break</span><span class="sy4">;</span></span>
  <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
  updateGL<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// redessine</span></pre>    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">pause</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span>timerId <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// dans ce cas le timer ne tourne pas alors on le lance</span>
    timerId <span class="sy1">=</span> startTimer<span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="sy4">;</span>
    chronometre.<span class="me1">restart</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
    <span class="co1">// le timer tourne alors on l'arrête</span>
    killTimer<span class="br0">(</span>timerId<span class="br0">)</span><span class="sy4">;</span>
    timerId <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre>
<p>Ceci conclu l'ajout d'une simulation « temps réel » dans notre environnement graphique, ainsi que la partie principale de ce tutoriel.
<br>Le reste est constitué de diverses extensions telles que : dessiner des sphères, gérer les mouvements de la souris ou encore ajouter des textures.</p>

   <!-- ToC -->
    <a name="compl" id="compl"></a>
    <a name="expl6" id="exmpl6"></a>
    <div class="navcontainer">

      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
          <ul class="subnavlist">
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Sphères</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Gestion souris</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Textures</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl9">Dessin 2D</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#conc">Conclusion</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Compléments : dessins de sphères
    </h2>


    <p>Nous n'avons jusqu'ici dessiné  qu'un triangle et des cubes. Dans cette section, nous allons voir comment dessiner des sphères et accessoirement un système d'axes (ce qui peut s'avérer très utile pour comprendre le
fonctionnement des transformations que l'on applique).<br>
    Nous repartons pour cela de <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">l'exemple 4</a>.</p>
    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06.zip">télécharger ici le code de ce sixième exemple</a>.
    </p>

    <p>Commençons par dessiner un système d'axes, avec, par exemple, au choix un dessin tout en blanc ou alors coloré&nbsp;: rouge pour <var>x</var>, vert pour <var>y</var> et bleu pour <var>z</var>.</p>
    <p>Cela se fait simplement en ajoutant tout d'abord une méthode dans <code>VueOpenGL</code>, dans le
    fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a> :
</p>
<pre class="cpp">  <span class="co1">// méthodes utilitaires offertes pour simplifier</span>
<span class="xtra ln-xtra">  <span class="kw4">void</span> dessineAxes<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue, <span class="kw4">bool</span> en_couleur <span class="sy1">=</span> <span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span></span>
  <span class="kw4">void</span> dessineCube<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue <span class="sy1">=</span> QMatrix4x4<span class="br0">(</span><span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span></pre>    <p>puis en la définissant dans <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a> :
</p>
<pre class="cpp">&nbsp;
<span class="co1">// ======================================================================</span>
<span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessineAxes</span> <span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue, <span class="kw4">bool</span> en_couleur<span class="br0">)</span>
<span class="br0">{</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"vue_modele"</span>, matrice_vue <span class="sy2">*</span> point_de_vue<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  glBegin<span class="br0">(</span>GL_LINES<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// axe X</span>
  <span class="kw1">if</span> <span class="br0">(</span>en_couleur<span class="br0">)</span> <span class="br0">{</span>
    prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// rouge</span>
  <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
    prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// blanc</span>
  <span class="br0">}</span>    
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// axe Y</span>
  <span class="kw1">if</span> <span class="br0">(</span>en_couleur<span class="br0">)</span> prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// vert</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// axe Z</span>
  <span class="kw1">if</span> <span class="br0">(</span>en_couleur<span class="br0">)</span> prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// bleu</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;</pre><p>Nous utilisons ici simplement la directive <code>GL_LINES</code> pour ne dessiner que des segments de droites.</p>

    <p>Dessiner une sphère est par contre plus compliqué (d'où cette section !). Il n'existe en effet pas de méthode OpenGL toute faite pour cela et il faut donc calculer le maillage de points nous-mêmes.</p>

    <p>Nous allons pour cela créer une nouvelle classe <code>GlSphere</code> qui contiendra donc le modèle de sphère que nous souhaitons dessiner. Nous calculons ce modèles (ensemble de points-supports) une fois pour toutes lors de l'initialisation, puis nous utiliserons ce modèle (auquel on appliquera translations, homothéties et rotations) à chaque fois que nous voudrons dessiner une nouvelle sphère.</p>

    <p>Commençons donc par la classe  <code>GlSphere</code> 
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/glsphere.h">fichier <code class="file">glsphere.h</code></a>) :</p>    
<pre class="cpp"><span class="co2">#ifndef GLSPHERE_H</span>
<span class="co2">#define GLSPHERE_H</span>
&nbsp;
<span class="co2">#include &lt;QGLBuffer&gt;</span>
<span class="co2">#include &lt;QGLShaderProgram&gt;</span>
&nbsp;
<span class="kw2">class</span> GLSphere
<span class="br0">{</span>
<span class="kw2">public</span><span class="sy4">:</span>
 GLSphere<span class="br0">(</span><span class="br0">)</span>
   <span class="sy4">:</span> vbo<span class="br0">(</span>QGLBuffer<span class="sy4">::</span><span class="me2">VertexBuffer</span><span class="br0">)</span>, ibo<span class="br0">(</span>QGLBuffer<span class="sy4">::</span><span class="me2">IndexBuffer</span><span class="br0">)</span>
 <span class="br0">{</span><span class="br0">}</span>
&nbsp;
  <span class="kw4">void</span> initialize<span class="br0">(</span>GLuint slices <span class="sy1">=</span> <span class="nu0">25</span>, GLuint stacks <span class="sy1">=</span> <span class="nu0">25</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw4">void</span> draw<span class="br0">(</span>QGLShaderProgram<span class="sy3">&amp;</span> program, <span class="kw4">int</span> attributeLocation<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="kw4">void</span> bind<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">void</span> release<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
<span class="kw2">private</span><span class="sy4">:</span>
  QGLBuffer vbo, ibo<span class="sy4">;</span>
  GLuint vbo_sz<span class="sy4">;</span>
  GLuint ibo_sz<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co2">#endif // GLSPHERE_H</span></pre>
<p>Le but n'est pas du tout d'expliquer les détails ici, mais simplement de fournir du code utilisable. Dans les grandes lignes, cette classe contient (sa partie privée) le tableau des points-supports utilisés pour dessiner une sphère.</p>
<p>Nous décidons de plus d'avoir :</p>
<ul>
  <li><p>une méthode <code>initialize</code> pour son initialisation&nbsp;; cette méthode prend le nombre de «tranches» que l'on veut utiliser pour représenter la sphère, dans le sens des longitudes puis des latitudes ; les valeurs par défaut sont de 25 tranches ;</p>
  </li>
  <li><p>une méthode <code>draw</code> pour dessiner la sphère (avec un «&nbsp;shader&nbsp;» donné) ;</p></li>
  <li><p>et deux méthodes <code>bind</code> et <code>release</code>, pas nécessaires pour nos exemples simples.</p></li>
</ul>

<p>Le
<a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/glsphere.cc">fichier <code class="file">glsphere.cc</code></a> implémente ensuite ces différentes méthodes.</p>    
<p>Il faut également penser à rajouter ces deux fichiers au «&nbsp;.pro&nbsp;» :</p>
<pre class="cpp">QT             <span class="sy2">+</span><span class="sy1">=</span> opengl
QMAKE_CXXFLAGS <span class="sy2">+</span><span class="sy1">=</span> <span class="sy2">-</span>std<span class="sy1">=</span>c<span class="sy2">++</span><span class="nu0">11</span>
&nbsp;
greaterThan<span class="br0">(</span>QT_MAJOR_VERSION, <span class="nu0">4</span><span class="br0">)</span><span class="sy4">:</span> QT <span class="sy2">+</span><span class="sy1">=</span> widgets
&nbsp;
TARGET <span class="sy1">=</span> ex_06_gl
&nbsp;
INCLUDEPATH <span class="sy1">=</span> ..<span class="sy2">/</span>general
&nbsp;
SOURCES <span class="sy2">+</span><span class="sy1">=</span> \
    main_qt_gl.<span class="me1">cc</span> \
    glwidget.<span class="me1">cc</span> \
<span class="xtra ln-xtra">    glsphere.<span class="me1">cc</span> \</span>
    vue_opengl.<span class="me1">cc</span>
&nbsp;
HEADERS <span class="sy2">+</span><span class="sy1">=</span> \
    glwidget.<span class="me1">h</span> \
    vertex_shader.<span class="me1">h</span> \
    vue_opengl.<span class="me1">h</span> \
<span class="xtra ln-xtra">    glsphere.<span class="me1">h</span> \</span>
    ..<span class="sy2">/</span>general<span class="sy2">/</span>dessinable.<span class="me1">h</span> \
    ..<span class="sy2">/</span>general<span class="sy2">/</span>support_a_dessin.<span class="me1">h</span> \
    ..<span class="sy2">/</span>general<span class="sy2">/</span>contenu.<span class="me1">h</span>
&nbsp;
RESOURCES <span class="sy2">+</span><span class="sy1">=</span> \
    resource.<span class="me1">qrc</span></pre>
<p>Voyons maintenant comment utiliser ce modèle de sphère. Tout d'abord nous ajoutons une <code>GLSphere</code> comme attribut à la classe <code>VueOpenGL</code>
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a>) :
</p>
<pre class="cpp"> <span class="kw2">private</span><span class="sy4">:</span>
  <span class="co1">// Un shader OpenGL encapsulé dans une classe Qt</span>
  QGLShaderProgram prog<span class="sy4">;</span>
<span class="xtra ln-xtra">  GLSphere sphere<span class="sy4">;</span></span></pre>
<p>Il faut, bien sûr, penser à l'initialiser 
(méthode <code>init</code>, fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp">  glEnable<span class="br0">(</span>GL_DEPTH_TEST<span class="br0">)</span><span class="sy4">;</span>
  glEnable<span class="br0">(</span>GL_CULL_FACE<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
<span class="xtra ln-xtra">  sphere.<span class="me1">initialize</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>                                      <span class="co1">// initialise la sphère</span></span>
  initializePosition<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
<p>Puis ajoutons, par exemple, une méthode <code>dessineSphere</code>
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a>) :</p>
<pre class="cpp">  <span class="co1">// méthodes utilitaires offertes pour simplifier</span>
  <span class="kw4">void</span> dessineAxes<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue, <span class="kw4">bool</span> en_couleur <span class="sy1">=</span> <span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">void</span> dessineCube<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue <span class="sy1">=</span> QMatrix4x4<span class="br0">(</span><span class="br0">)</span> <span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  <span class="kw4">void</span> dessineSphere<span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue,</span>
<span class="xtra ln-xtra">                     <span class="kw4">double</span> rouge <span class="sy1">=</span> <span class="nu16">1.0</span>, <span class="kw4">double</span> vert <span class="sy1">=</span> <span class="nu16">1.0</span>, <span class="kw4">double</span> bleu <span class="sy1">=</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span></pre><p>que nous définissons tout simplement ainsi 
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessineSphere</span> <span class="br0">(</span>QMatrix4x4 <span class="kw4">const</span><span class="sy3">&amp;</span> point_de_vue,
                               <span class="kw4">double</span> rouge, <span class="kw4">double</span> vert, <span class="kw4">double</span> bleu<span class="br0">)</span>
<span class="br0">{</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"vue_modele"</span>, matrice_vue <span class="sy2">*</span> point_de_vue<span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, rouge, vert, bleu<span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// met la couleur</span>
  sphere.<span class="me1">draw</span><span class="br0">(</span>prog, SommetId<span class="br0">)</span><span class="sy4">;</span>                           <span class="co1">// dessine la sphère</span>
<span class="br0">}</span></pre>
<p>Reste à l'utiliser (méthode <code>dessine</code> de <code>VueOpenGL</code>).
Décidons par exemple de dessiner :</p>
<ul>
  <li><p>les axes du repère principal ;</p>
</li>
  <li><p>une sphère en mode « fil de fer », bleue de rayon 1.0, centrée en (-0.5, 0, -2), avec ses axes propres dessinés en blanc ;</p>
</li>
  <li><p>une sphère jaune de rayon 0.5 centrée en (1, 0, -2) et tournée de -30 degrés par rapport à l'axe Oy puis de -30 degrés par rapport à 0x ;</p>
</li>
  <li><p>une sphère rouge, remplie, de rayon 0.125 centrée en (0, 0, -2).</p>
</li>
</ul>

<p>Ce qui nous donne
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_06/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp"><span class="kw4">void</span> VueOpenGL<span class="sy4">::</span><span class="me2">dessine</span><span class="br0">(</span>Contenu <span class="kw4">const</span><span class="sy3">&amp;</span> a_dessiner<span class="br0">)</span>
<span class="br0">{</span>
  Q_UNUSED<span class="br0">(</span>a_dessiner<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// dans cet exemple simple on n'utilise pas le paramètre</span>
&nbsp;
  glClear<span class="br0">(</span>GL_COLOR_BUFFER_BIT <span class="sy3">|</span> GL_DEPTH_BUFFER_BIT<span class="br0">)</span><span class="sy4">;</span>       <span class="co1">// efface l'écran</span>
&nbsp;
  QMatrix4x4 matrice<span class="sy4">;</span>
&nbsp;
  dessineAxes<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// dessine le repère principal</span>
&nbsp;
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="sy2">-</span><span class="nu16">0.5</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>
  glPolygonMode<span class="br0">(</span>GL_FRONT_AND_BACK, GL_LINE<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// passe en mode "fil de fer"</span>
  dessineSphere<span class="br0">(</span>matrice, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// bleu</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">1.5</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// taille des axes (1.5 pour qu'ils dépassent un peu)</span>
  dessineAxes<span class="br0">(</span>matrice, <span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// dessine (en blanc) les axes de la sphere</span>
&nbsp;
  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.5</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="sy2">-</span><span class="nu0">30</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">rotate</span><span class="br0">(</span><span class="sy2">-</span><span class="nu0">30</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  dessineSphere<span class="br0">(</span>matrice, <span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// jaune</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">1.5</span><span class="br0">)</span><span class="sy4">;</span>
  dessineAxes<span class="br0">(</span>matrice<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// dessine (en couleur) les axes de la sphere</span>
&nbsp;
  glPolygonMode<span class="br0">(</span>GL_FRONT_AND_BACK, GL_FILL<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// repasse en mode "plein"</span>
&nbsp;
  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">translate</span><span class="br0">(</span><span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">scale</span><span class="br0">(</span><span class="nu16">0.125</span><span class="br0">)</span><span class="sy4">;</span>
  dessineSphere<span class="br0">(</span>matrice, <span class="nu16">1.0</span>, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// rouge</span>
<span class="br0">}</span></pre>

    <!-- ToC -->
    <a name="expl7" id="exmpl7"></a>
    <div class="navcontainer">

      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
          <ul class="subnavlist">
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Sphères</a>
            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Gestion souris</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Textures</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl9">Dessin 2D</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#conc">Conclusion</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Compléments : gestion mouvement souris
    </h2>

    <p>Nous avions ajouté la gestion d'«&nbsp;évènements clavier&nbsp;» pour déplacer le point de vue. On peut aussi gérer des «&nbsp;évènements souris&nbsp;».
    Nous repartons pour cela de <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">l'exemple 4</a>.</p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_07.zip">télécharger ici le code de ce septième exemple</a>.
    </p>

    <p>Pour gérer des «&nbsp;évènements souris&nbsp;», il suffit d'ajouter deux méthodes
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_07/Qt_GL/glwidget.h">fichier <code class="file">glwidget.h</code></a>) :</p>    
    <pre class="cpp">  <span class="co1">// Méthodes de gestion d'évènements</span>
  <span class="kw2">virtual</span> <span class="kw4">void</span> keyPressEvent<span class="br0">(</span>QKeyEvent<span class="sy2">*</span> event<span class="br0">)</span> override<span class="sy4">;</span>
<span class="xtra ln-xtra">  <span class="kw2">virtual</span> <span class="kw4">void</span> mousePressEvent<span class="br0">(</span>QMouseEvent<span class="sy2">*</span> event<span class="br0">)</span> override<span class="sy4">;</span></span>
<span class="xtra ln-xtra">  <span class="kw2">virtual</span> <span class="kw4">void</span> mouseMoveEvent<span class="br0">(</span>QMouseEvent<span class="sy2">*</span> event<span class="br0">)</span>  override<span class="sy4">;</span></span></pre>
    <p>Nous allons de plus ici ajouter un attribut pour se souvenir de la position de la souris 
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_07/Qt_GL/glwidget.h">fichier <code class="file">glwidget.h</code></a>) :</p>    
    <pre class="cpp">  <span class="co1">// position de la souris</span>
<span class="xtra ln-xtra">  QPointF lastMousePosition<span class="sy4">;</span></span>
<span class="br0">}</span><span class="sy4">;</span></pre>
    <p>Pour la méthode <code>mousePressEvent</code>, qui est appelée lorsqu'un bouton de souris est enfoncé, nous allons simplement mémoriser la position de la souris :
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_07/Qt_GL/glwidget.cc">fichier <code class="file">glwidget.cc</code></a>) :</p>    
    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">mousePressEvent</span><span class="br0">(</span>QMouseEvent<span class="sy2">*</span> event<span class="br0">)</span>
<span class="br0">{</span>
  lastMousePosition <span class="sy1">=</span> event<span class="sy2">-</span><span class="sy1">&gt;</span>posF<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
    <p>Pour la méthode <code>mouseMoveEvent</code>, appelée lorsque la  souris est déplacée (avec un bouton enfoncé, voir le commentaire dans le code), nous allons effectuer une rotation de la scène que si le bouton gauche est maintenu enfoncé, puis il ne faut pas oublier de lancer la méthode <code>updateGL</code> pour mettre à jour l'affichage :
(<a href="http://progmaph.epfl.ch/projet/src/qt/ex_07/Qt_GL/glwidget.cc">fichier <code class="file">glwidget.cc</code></a>) :</p>    
    <pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">mouseMoveEvent</span><span class="br0">(</span>QMouseEvent<span class="sy2">*</span> event<span class="br0">)</span>
<span class="br0">{</span>
  <span class="coMULTI">/* If mouse tracking is disabled (the default), the widget only receives
   * mouse move events when at least one mouse button is pressed while the
   * mouse is being moved.
   *
   * Pour activer le "mouse tracking" if faut lancer setMouseTracking(true)
   * par exemple dans le constructeur de cette classe.
   */</span>
&nbsp;
  <span class="kw1">if</span> <span class="br0">(</span>event<span class="sy2">-</span><span class="sy1">&gt;</span>buttons<span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;</span> Qt<span class="sy4">::</span><span class="me2">LeftButton</span><span class="br0">)</span> <span class="br0">{</span>
    constexpr <span class="kw4">double</span> petit_angle<span class="br0">(</span><span class="nu18">.4</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// en degrés</span>
&nbsp;
    <span class="co1">// Récupère le mouvement relatif par rapport à la dernière position de la souris</span>
    QPointF d <span class="sy1">=</span> event<span class="sy2">-</span><span class="sy1">&gt;</span>posF<span class="br0">(</span><span class="br0">)</span> <span class="sy2">-</span> lastMousePosition<span class="sy4">;</span>
    lastMousePosition <span class="sy1">=</span> event<span class="sy2">-</span><span class="sy1">&gt;</span>posF<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    vue.<span class="me1">rotate</span><span class="br0">(</span>petit_angle <span class="sy2">*</span> d.<span class="me1">manhattanLength</span><span class="br0">(</span><span class="br0">)</span>, d.<span class="me1">y</span><span class="br0">(</span><span class="br0">)</span>, d.<span class="me1">x</span><span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    updateGL<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre>
<p>Et voilà ! Vous pouvez déplacer la scène en bougeant la souris lorsque le bouton gauche est enfoncé.</p>
    
   <!-- ToC -->
    <a name="expl8" id="exmpl8"></a>
    <div class="navcontainer">

      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
          <ul class="subnavlist">
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Sphères</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Gestion souris</a>
            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Textures</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl9">Dessin 2D</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#conc">Conclusion</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Compléments : textures
    </h2>

    <p>Dans cette section, nous allons voir comment plaquer des images («&nbsp;textures&nbsp;») sur les objets dessinés.<br>
    Nous repartons pour cela de <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">l'exemple 4</a>.</p>

    <p class="note">
      <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08.zip">télécharger ici le code de ce huitième exemple</a>.
    </p>


    <p>La toute première chose pour mettre des textures est bien sûr d'avoir des images. Ici nous utiliserons une image de chat, <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/cat.jpeg"><code>cat.jpeg</code></a>, et un zoom sur une partie de l'ensemble de Mandelbrot <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/mandelbrot.jpeg"><code>mandelbrot.jpeg</code></a>.<br> Pour que ces images soient inclues dans l'exécutable, nous ajoutons le nom de ces fichiers à notre <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/resource.qrc">fichier <code>ressource.qrc</code></a>.
    </p>

    <p>Nous devons ensuite modifier notre « shader » (fichiers <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vertex_shader.glsl"><code>vertex_shader.glsl</code></a>, <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vertex_shader.h"><code>vertex_shader.h</code></a> et <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/fragment_shader.glsl"><code>fragment_shader.glsl</code></a>), de sorte à remplacer la couleur par une texture. Remarquez que l'enum <code>CouleurId</code> a été remplacé par <code>CoordonneeTextureId</code>.</p>


    <p>Il faut aussi le faire dans l'initialisation du shader
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp">  prog.<span class="me1">bindAttributeLocation</span><span class="br0">(</span><span class="st0">"sommet"</span>,  SommetId<span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">bindAttributeLocation</span><span class="br0">(</span><span class="st0">"coordonnee_texture"</span>, CoordonneeTextureId<span class="br0">)</span><span class="sy4">;</span></span></pre>

    <p>Dans cette initialisation, nous devons également allouer les ressources pour charger les textures dans OpenGL (sur la carte graphique s'il y en a une).
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
<pre class="cpp">  <span class="co1">// Préparation d'une première texture à partir d'une image (cat.jpeg).</span>
  QGLContext<span class="sy2">*</span> context <span class="sy1">=</span>  <span class="kw2">const_cast</span><span class="sy1">&lt;</span>QGLContext<span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>QGLContext<span class="sy4">::</span><span class="me2">currentContext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
  textureDeChat <span class="sy1">=</span> context<span class="sy2">-</span><span class="sy1">&gt;</span>bindTexture<span class="br0">(</span>QPixmap<span class="br0">(</span><span class="st0">":/cat.jpeg"</span><span class="br0">)</span>, GL_TEXTURE_2D<span class="br0">)</span><span class="sy4">;</span>
  glTexParameteri<span class="br0">(</span>GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT<span class="br0">)</span><span class="sy4">;</span>
  glTexParameteri<span class="br0">(</span>GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT<span class="br0">)</span><span class="sy4">;</span>
  <span class="co1">// Autres variantes au lieu de GL_MIRRORED_REPEAT : GL_REPEAT, GL_CLAMP_TO_EDGE</span>
&nbsp;
  <span class="co1">// Préparation d'une seconde texture.</span>
  <span class="co1">// S'il y devait y en avoir plus, on ferait bien sûr une fonction ;-)</span>
  textureFractale <span class="sy1">=</span> context<span class="sy2">-</span><span class="sy1">&gt;</span>bindTexture<span class="br0">(</span>QPixmap<span class="br0">(</span><span class="st0">":/mandelbrot.jpeg"</span><span class="br0">)</span>, GL_TEXTURE_2D<span class="br0">)</span><span class="sy4">;</span>
  glTexParameteri<span class="br0">(</span>GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT<span class="br0">)</span><span class="sy4">;</span>
  glTexParameteri<span class="br0">(</span>GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT<span class="br0">)</span><span class="sy4">;</span></pre>
<p>Nous aurons donc pris soin d'ajouter comme attributs de quoi identifier nos textures (simples numéros qui identifient l'image)
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a>) :</p>
<pre class="cpp">  <span class="co1">// Textures utilisées</span>
  GLuint textureDeChat<span class="sy4">;</span>
  GLuint textureFractale<span class="sy4">;</span></pre>
	
    <p>Lors du dessin du cube, nous devons activer les textures puis les attacher à chaque coin de chaque face
(fichier <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a>) :</p>
    <pre class="cpp">  <span class="co1">/// Indique au shader quelle numéro de texture il doit utiliser (0,1,2,...)</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"textureId"</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span></span>
&nbsp;
  <span class="co1">/// Attribut la texture 'textureDeChat' à la texture numéro 0 du shader</span>
<span class="xtra ln-xtra">  glActiveTexture<span class="br0">(</span>GL_TEXTURE0<span class="br0">)</span><span class="sy4">;</span></span>
<span class="xtra ln-xtra">  glBindTexture<span class="br0">(</span>GL_TEXTURE_2D, textureDeChat<span class="br0">)</span><span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// Commence le dessin du cube.</span>
  <span class="co1">// On dessine le cube en deux étapes pour pouvoir changer de texture.</span>
  glBegin<span class="br0">(</span>GL_QUADS<span class="br0">)</span><span class="sy4">;</span>
  <span class="co1">// X+</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// X-</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Y+</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">/// On remplace la précédente texture de chat par la texture de fractale</span>
<span class="xtra ln-xtra">  glActiveTexture<span class="br0">(</span>GL_TEXTURE0<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// On la lie à nouveau au numéro 0 (comme ca on a pas besoin de changer "textureId" du shader)</span></span>
<span class="xtra ln-xtra">  glBindTexture<span class="br0">(</span>GL_TEXTURE_2D, textureFractale<span class="br0">)</span><span class="sy4">;</span></span>
&nbsp;
  <span class="co1">// Continue le dessin du cube.</span>
  glBegin<span class="br0">(</span>GL_QUADS<span class="br0">)</span><span class="sy4">;</span>
  <span class="co1">// Y-</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Z+</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="co1">// Z-</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="xtra ln-xtra">  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CoordonneeTextureId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span></span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre><p>Il faut imaginer une texture comme une nappe carrée. Les quatre coins de la nappe sont repérés par 4 vecteurs en dimension 2 <code>(0,0), (0,1), (1,1) et (1,0)</code>. Il faut imaginer que cette nappe va pouvoir être déformée autant que l'on veut pour être plaquée contre les faces que l'on va dessiner. Pour indiquer à OpenGL quelle partie de la texture (la nappe) il faut mettre sur chaque sommet on utilise l'attribut <code>CoordonneeTextureId</code>.</p>

<p>Finalement, on ajoute aussi un destructeur, pour libérer les textures allouées :
fichiers <a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vue_opengl.h"><code>vue_opengl.h</code></a> :</p>
<pre class="cpp">  ~VueOpenGL<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></pre>    <p>et
<a href="http://progmaph.epfl.ch/projet/src/qt/ex_08/Qt_GL/vue_opengl.cc"><code>vue_opengl.cc</code></a> :</p>
<pre class="cpp">VueOpenGL<span class="sy4">::</span>~VueOpenGL<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// Libère la mémoire des textures</span>
&nbsp;
  QGLContext<span class="sy2">*</span> context <span class="sy1">=</span>  <span class="kw2">const_cast</span><span class="sy1">&lt;</span>QGLContext<span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>QGLContext<span class="sy4">::</span><span class="me2">currentContext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  context<span class="sy2">-</span><span class="sy1">&gt;</span>deleteTexture<span class="br0">(</span>textureDeChat<span class="br0">)</span><span class="sy4">;</span>
  context<span class="sy2">-</span><span class="sy1">&gt;</span>deleteTexture<span class="br0">(</span>textureFractale<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>
    <p>Ceci conclut cet exemple de plaquage de deux textures.</p>
    
   <!-- ToC -->
    <a name="expl9" id="exmpl9"></a>
    <div class="navcontainer">

      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
          <ul class="subnavlist">
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Sphères</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Gestion souris</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Textures</a>
            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl9">Dessin 2D</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#conc">Conclusion</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Compléments : dessins 2D
    </h2>

      <p>Pour dessiner en 2D en OpenGl, il suffit en fait de dessiner
      dans un plan perpendiculaire à la direction de visée. Je n'ai
      donc pas grand chose de plus à dire ici que ce que nous avons présenté
      dans <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl1">le tout premier exemple</a>.</p>

    <p class="note">
    <strong>NOTE&nbsp;:</strong> Vous pouvez <a href="http://progmaph.epfl.ch/projet/src/qt/ex_09.zip">télécharger ici le code de ce neuvième exemple</a>.
    </p>

<p>Par contre, pour dessiner de proche en proche (approximation
linéaire) des fonction dans le plan, il peut être utile d'utiliser la
directive <code class="code">GL_LINE_SPLIT</code>.</p>

<p>Voici un exemple qui dessine la fonction sinus (fichier
<a href="http://progmaph.epfl.ch/projet/src/qt/ex_09/glwidget.cc"><code>glwidget.cc</code></a>) :</p>
<pre class="cpp"><span class="kw4">void</span> GLWidget<span class="sy4">::</span><span class="me2">paintGL</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  glClear<span class="br0">(</span>GL_COLOR_BUFFER_BIT <span class="sy3">|</span> GL_DEPTH_BUFFER_BIT<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  QMatrix4x4 matrice<span class="sy4">;</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"vue_modele"</span>, matrice<span class="br0">)</span><span class="sy4">;</span>              <span class="co1">// On met la matrice identité dans vue_modele</span>
&nbsp;
  <span class="coMULTI">/* Dessine le cadre blanc */</span>
  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">ortho</span><span class="br0">(</span><span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">10.0</span>, <span class="nu16">10.0</span><span class="br0">)</span><span class="sy4">;</span>         <span class="co1">// matrice simple pour faire le cadre</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"projection"</span>, matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">1.0</span>, <span class="nu16">1.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  glBegin<span class="br0">(</span>GL_LINE_LOOP<span class="br0">)</span><span class="sy4">;</span>                                    <span class="co1">// la primitive LINE_LOOP referme le tracé avec une ligne (n lignes)</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// le 2.0 dans la composante z permet de mettre le cadre par dessus tout</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// ceci fonctionne grace à l'option GL_DEPTH_TEST</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="sy2">-</span><span class="nu16">1.0</span>, <span class="sy2">+</span><span class="nu16">1.0</span>, <span class="nu16">2.0</span><span class="br0">)</span><span class="sy4">;</span>
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Change de matrice de projection adpatée aux zoom du graph */</span>
  matrice.<span class="me1">setToIdentity</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">double</span> xmin<span class="br0">(</span><span class="sy2">-</span><span class="nu16">2.0</span> <span class="sy2">*</span> M_PI<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">double</span> xmax<span class="br0">(</span><span class="sy2">+</span><span class="nu16">2.0</span> <span class="sy2">*</span> M_PI<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">double</span> ymin<span class="br0">(</span><span class="sy2">-</span><span class="nu16">1.2</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw4">double</span> ymax<span class="br0">(</span><span class="sy2">+</span><span class="nu16">1.2</span><span class="br0">)</span><span class="sy4">;</span>
  matrice.<span class="me1">ortho</span><span class="br0">(</span>xmin, xmax, ymin, ymax, <span class="sy2">-</span><span class="nu16">10.0</span>, <span class="nu16">10.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setUniformValue</span><span class="br0">(</span><span class="st0">"projection"</span>, matrice<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Dessine les axes */</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">0.0</span>, <span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  glBegin<span class="br0">(</span>GL_LINES<span class="br0">)</span><span class="sy4">;</span>                                        <span class="co1">// la primitive LINES dessine une ligne par paire de points (n/2 lignes)</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, xmin, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// le -1.0 dans la composante z met les axes en arrière plan</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, xmax, <span class="nu16">0.0</span>, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, ymin, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, <span class="nu16">0.0</span>, ymax, <span class="sy2">-</span><span class="nu16">1.0</span><span class="br0">)</span><span class="sy4">;</span>
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
  <span class="coMULTI">/* Dessine la fonction sinus */</span>
  prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>CouleurId, <span class="nu16">0.0</span>, <span class="nu16">1.0</span>, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  glBegin<span class="br0">(</span>GL_LINE_STRIP<span class="br0">)</span><span class="sy4">;</span>                                   <span class="co1">// la primitive LINE_STRIP ne referme par le tracé (n-1 lignes)</span>
  <span class="kw4">double</span> xpas<span class="br0">(</span><span class="br0">(</span>xmax <span class="sy2">-</span> xmin<span class="br0">)</span> <span class="sy2">/</span> <span class="nu16">128.0</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">double</span> x<span class="br0">(</span>xmin<span class="br0">)</span><span class="sy4">;</span> x <span class="sy1">&lt;=</span> xmax<span class="sy4">;</span> x <span class="sy2">+</span><span class="sy1">=</span> xpas<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">double</span> y <span class="sy1">=</span> std<span class="sy4">::</span><span class="kw3">sin</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span>
    prog.<span class="me1">setAttributeValue</span><span class="br0">(</span>SommetId, x, y, <span class="nu16">0.0</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
  glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre>    
   <!-- ToC -->
    <a name="compl" id="compl"></a>
    <div class="navcontainer">

      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>
          <ul class="subnavlist">
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl6">Sphères</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">Gestion souris</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl8">Textures</a>
            </li>
            <li class="sublist">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl9">Dessin 2D</a>
            </li>
            <li class="subactive">
              <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#conc">Conclusion</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Conclusion
    </h2>
    <p>
      Qu'ai-je oublié&nbsp;?...
    </p>
    <p>
      Plein de choses bien sûr ; ceci n'est qu'un très modeste
      tutoriel. Pour aller plus loin, voir dans la <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">bibliographie ci-dessous</a>.
    </p>
    <p>
      Ce que vous me demanderez peut être pour le projet&nbsp;:
    </p>
    <ul>


      <li>
        <p>
          <strong>Comment dessiner autre chose que des cubes ou des sphères&nbsp;?</strong>
        </p>
        <p>
          Pour dessiner des cubes et des sphères, ou toute transformation
          affine de ces objets, voir les exemples précédents.
        </p>

      <p>
          Pour le reste, il faut décomposer l'objet à dessiner en
          facettes triangulaires ou rectangulaires (cf l'exemple du
      cube). Je vous conseille pour cela de faire des méthodes-outils, comme nous avons fait pour les cubes et les axes, voire des classes comme nous avons fait
      pour les sphères.
      </p>

      <p>Pour dessiner des objets complexes, il vaut mieux utiliser logiciel de rendu 3D comme par exemple <a href="http://www.blender.org/">blender</a>. On peut ensuite charger les modèles 3D dans notre programme par exemple avec la librairie <a href="https://github.com/assimp/assimp">assimp</a>. Mais cela nous emmènerait vraiment beaucoup trop loin <code>;-)</code></p>
      
      </li>

      <li><p><strong>Comment modifier la perspective&nbsp;?</strong></p>

<p>On peut modifier la perspective en modifiant les paramètres de la
méthode <code> perspective()</code> de <code>QMatrix4x4</code> appelée dans la
      méthode <code>resizeGL()</code> de <code>GLWidget</code> (ou alors en changeant directement la matrice
      « <code>projection</code> » du « shader » !).</p> <p> Le premier paramètre correspond à
l'angle d'ouverture du cône de vision. Habituellement cette valeur se
situe entre 65 et 100 degrés. Le deuxième paramètre est le format de la
fenêtre, ratio largeur/hauteur. Les deux derniers
paramètres définissent quels objets seront représentés à l'écran. Ici,
tout se qui se situe à une distance entre 1e-3 et 1e5 de l'oeil sera
dessiné à l'écran. Pour des raisons de performance, il est déconseillé
de descendre trop prêt de 0 pour la limite inférieure.  </p>
</li>

      <li><p><strong>Que faire si je ne sais plus où je me situe dans
      l'espace après avoir fait trop de
      déplacements&nbsp;?</strong></p>

<p>Une possibilité est de revenir à l'origine en donnant comme point de vue la matrice identité, par exemple
avec la méthode
<code>setToIdentity()</code>, ou à un autre point fixe défini au départ, exactement comme nous l'avons
montré dans <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl4">l'exemple 4</a> pour la touche 'Home'.</p><p> Une autre possibilité est de créer et d'appeler une
méthode <code>dessineAxes()</code>, comme illustrée <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#exmpl7">dans le septième exemple</a>, qui dessine un
système orthonormé à l'endroit où l'on se
situe.</p>
</li>


      <li>

      <p><strong>Que faire si je ne sais pas comment utiliser une
      fonction ou si je ne sais pas comment réaliser ce que
      j'aimerais&nbsp;?</strong></p>
      
	<p> La première chose à faire est de chercher dans la
	documentation, via les liens fournis ci-dessous. Une grande
	partie du temps du programmeur est consacré à la recherche
	d'informations dans une documentation.  Si vous n'avez pas
	trouvé ou que vous n'êtes pas satisfait de la réponse, posez
	votre question sur le forum du cours.
      </p>

</li>






      
    </ul>

    <!-- ToC -->
    <a name="biblio" id="biblio"></a>
    <div class="navcontainer">
      <ul class="navlist">
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#intro">Introduction</a>
        </li>
        <li>

          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#d3d">Dessin 3D</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#simul">Simulation</a>
        </li>
        <li>
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#compl">Compléments</a>

        </li>
        <li class="active">
          <a href="http://progmaph.epfl.ch/projet/tutoriel_Qt.php#biblio">Bibliographie</a>
        </li>
      </ul>
    </div>
    <h2>
      Bibliographie
    </h2>

    <ul>
      <li>
        <span class="indication">[EN]</span> <a href="http://qt-project.org/doc/qt-4.8/classes.html" target="other">Documentation Qt</a>
      </li>
      
      <li>
        <span class="indication">[FR]</span> <a href="http://openclassrooms.com/courses/programmez-avec-le-langage-c/introduction-a-qt" target="other">Tutoriel pour faire des fenêtres avec Qt</a> avec des boutons, des champs de textes, etc., mais pas d'OpenGL dans ce tutoriel.
      </li>
      
      <li>
        <span class="indication">[EN]</span> <a href="https://www.opengl.org/sdk/docs/" target="other">Documentation officielle OpenGL</a>
      </li>

      <li>
        <span class="indication">[EN]</span> <a href="http://www.opengl-tutorial.org/" target="other">Un tutoriel OpenGL 3.3</a>     
      </li>

      <li>
        <span class="indication">[EN]</span> <a href="https://open.gl/" target="other">Un autre tutoriel OpenGL 3.3</a>      	
      </li>
      
    </ul>


    <hr>
    <div class="end">
      Auteurs&nbsp;: J.-C. Chappelier &amp; M. Geiger
      <br>
      <!-- hhmts start -->
<span lang="fr" id="datefr">Dernière mise à jour le 23 février 2015<br>
</span>
<span lang="en" id="dateen">
Last modified: Mon Feb 23, 2015
</span>
<!-- hhmts end -->
    </div>
  

</body></html>